
/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaOccVectorInstDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaOccVectorInstDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaOccVectorInstDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaOccVectorInstDefObject* self = (PyoaObserver_oaOccVectorInstDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaOccVectorInstDef(p1.Data());
            }
            else {
                pyv_oaObserver_oaOccVectorInstDef* p=new pyv_oaObserver_oaOccVectorInstDef(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaOccVectorInstDef(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaOccVectorInstDef* p=new pyv_oaObserver_oaOccVectorInstDef(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaOccVectorInstDef)
    {
        PyParamoaObserver_oaOccVectorInstDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaOccVectorInstDef_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaOccVectorInstDef(p1.Data());
            }
            else {
                pyv_oaObserver_oaOccVectorInstDef* p=new pyv_oaObserver_oaOccVectorInstDef(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaOccVectorInstDef, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaOccVectorInstDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaOccVectorInstDef_tp_dealloc(PyoaObserver_oaOccVectorInstDefObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaOccVectorInstDef*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaOccVectorInstDef_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaOccVectorInstDef value;
    int convert_status=PyoaObserver_oaOccVectorInstDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[51];
    sprintf(buffer,"<oaObserver_oaOccVectorInstDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaOccVectorInstDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaOccVectorInstDef v1;
    PyParamoaObserver_oaOccVectorInstDef v2;
    int convert_status1=PyoaObserver_oaOccVectorInstDef_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaOccVectorInstDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaOccVectorInstDef_Convert(PyObject* ob,PyParamoaObserver_oaOccVectorInstDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaOccVectorInstDef_Check(ob)) {
        result->SetData( (oaObserver_oaOccVectorInstDef*) ((PyoaObserver_oaOccVectorInstDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaOccVectorInstDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaOccVectorInstDef_FromoaObserver_oaOccVectorInstDef(oaObserver_oaOccVectorInstDef* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaOccVectorInstDef_Type.tp_alloc(&PyoaObserver_oaOccVectorInstDef_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaOccVectorInstDefObject* self = (PyoaObserver_oaOccVectorInstDefObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaOccVectorInstDef::pyv_oaObserver_oaOccVectorInstDef(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaOccVectorInstDef(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaOccVectorInstDef::pyv_oaObserver_oaOccVectorInstDef(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaOccVectorInstDef(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaOccVectorInstDef::pyv_oaObserver_oaOccVectorInstDef(const oaObserver_oaOccVectorInstDef& p)
 : pyob(NULL),
   oaObserver_oaOccVectorInstDef(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaOccVectorInstDef::onPostCreate(oaOccVectorInstDef* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaOccVectorInstDef::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaOccVectorInstDef_FromoaOccVectorInstDef(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaOccVectorInstDef::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaOccVectorInstDef::onPostModify(oaOccVectorInstDef* p1,oaVectorInstDefModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaOccVectorInstDef::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaOccVectorInstDef_FromoaOccVectorInstDef(p1));
    PyTuple_SetItem(args,1,PyoaVectorInstDefModTypeEnum_FromoaVectorInstDefModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaOccVectorInstDef::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaOccVectorInstDef::onPreDestroy(oaOccVectorInstDef* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaOccVectorInstDef::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaOccVectorInstDef_FromoaOccVectorInstDef(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaOccVectorInstDef::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaOccVectorInstDef::onPreModify(oaOccVectorInstDef* p1,oaVectorInstDefModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaOccVectorInstDef::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaOccVectorInstDef_FromoaOccVectorInstDef(p1));
    PyTuple_SetItem(args,1,PyoaVectorInstDefModTypeEnum_FromoaVectorInstDefModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaOccVectorInstDef::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaOccVectorInstDef_doc[] = 
"Class: oaObserver_oaOccVectorInstDef\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaOccVectorInstDef(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaOccVectorInstDef||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaOccVectorInstDef\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaOccVectorInstDef(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaOccVectorInstDef||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaOccVectorInstDef\n"
"  Paramegers: (oaObserver_oaOccVectorInstDef)\n"
"    Calls: (const oaObserver_oaOccVectorInstDef&)\n"
"    Signature: oaObserver_oaOccVectorInstDef||cref-oaObserver_oaOccVectorInstDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaOccVectorInstDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaOccVectorInstDef",
    sizeof(PyoaObserver_oaOccVectorInstDefObject),
    0,
    (destructor)oaObserver_oaOccVectorInstDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaOccVectorInstDef_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaOccVectorInstDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaOccVectorInstDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaOccVectorInstDef_oaVectorInstDefModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaOccVectorInstDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaOccVectorInstDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaOccVectorInstDef_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaOccVectorInstDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaOccVectorInstDef",
           (PyObject*)(&PyoaObserver_oaOccVectorInstDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaOccVectorInstDef\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaOccurrence
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaOccurrence_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaOccurrence_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaOccurrenceObject* self = (PyoaObserver_oaOccurrenceObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaOccurrence(p1.Data());
            }
            else {
                pyv_oaObserver_oaOccurrence* p=new pyv_oaObserver_oaOccurrence(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaOccurrence(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaOccurrence* p=new pyv_oaObserver_oaOccurrence(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaOccurrence)
    {
        PyParamoaObserver_oaOccurrence p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaOccurrence_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaOccurrence(p1.Data());
            }
            else {
                pyv_oaObserver_oaOccurrence* p=new pyv_oaObserver_oaOccurrence(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaOccurrence, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaOccurrence)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaOccurrence_tp_dealloc(PyoaObserver_oaOccurrenceObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaOccurrence*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaOccurrence_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaOccurrence value;
    int convert_status=PyoaObserver_oaOccurrence_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaObserver_oaOccurrence::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaOccurrence_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaOccurrence v1;
    PyParamoaObserver_oaOccurrence v2;
    int convert_status1=PyoaObserver_oaOccurrence_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaOccurrence_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaOccurrence_Convert(PyObject* ob,PyParamoaObserver_oaOccurrence* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaOccurrence_Check(ob)) {
        result->SetData( (oaObserver_oaOccurrence*) ((PyoaObserver_oaOccurrenceObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaOccurrence Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaOccurrence_FromoaObserver_oaOccurrence(oaObserver_oaOccurrence* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaOccurrence_Type.tp_alloc(&PyoaObserver_oaOccurrence_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaOccurrenceObject* self = (PyoaObserver_oaOccurrenceObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaOccurrence::pyv_oaObserver_oaOccurrence(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaOccurrence(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaOccurrence::pyv_oaObserver_oaOccurrence(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaOccurrence(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaOccurrence::pyv_oaObserver_oaOccurrence(const oaObserver_oaOccurrence& p)
 : pyob(NULL),
   oaObserver_oaOccurrence(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaOccurrence::onPostCreate(oaOccurrence* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaOccurrence::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaOccurrence_FromoaOccurrence(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaOccurrence::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaOccurrence::onPostModify(oaOccurrence* p1,oaOccurrenceModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaOccurrence::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaOccurrence_FromoaOccurrence(p1));
    PyTuple_SetItem(args,1,PyoaOccurrenceModTypeEnum_FromoaOccurrenceModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaOccurrence::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaOccurrence::onPreDestroy(oaOccurrence* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaOccurrence::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaOccurrence_FromoaOccurrence(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaOccurrence::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaOccurrence::onPreModify(oaOccurrence* p1,oaOccurrenceModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaOccurrence::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaOccurrence_FromoaOccurrence(p1));
    PyTuple_SetItem(args,1,PyoaOccurrenceModTypeEnum_FromoaOccurrenceModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaOccurrence::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaOccurrence_doc[] = 
"Class: oaObserver_oaOccurrence\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaOccurrence(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaOccurrence||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaOccurrence\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaOccurrence(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaOccurrence||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaOccurrence\n"
"  Paramegers: (oaObserver_oaOccurrence)\n"
"    Calls: (const oaObserver_oaOccurrence&)\n"
"    Signature: oaObserver_oaOccurrence||cref-oaObserver_oaOccurrence,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaOccurrence_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaOccurrence",
    sizeof(PyoaObserver_oaOccurrenceObject),
    0,
    (destructor)oaObserver_oaOccurrence_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaOccurrence_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaOccurrence_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaOccurrence_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaOccurrence_oaOccurrenceModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaOccurrence_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaOccurrence_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaOccurrence_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaOccurrence\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaOccurrence",
           (PyObject*)(&PyoaObserver_oaOccurrence_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaOccurrence\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaOpPoint
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaOpPoint_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaOpPoint_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaOpPointObject* self = (PyoaObserver_oaOpPointObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaOpPoint(p1.Data());
            }
            else {
                pyv_oaObserver_oaOpPoint* p=new pyv_oaObserver_oaOpPoint(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaOpPoint(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaOpPoint* p=new pyv_oaObserver_oaOpPoint(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaOpPoint)
    {
        PyParamoaObserver_oaOpPoint p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaOpPoint_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaOpPoint(p1.Data());
            }
            else {
                pyv_oaObserver_oaOpPoint* p=new pyv_oaObserver_oaOpPoint(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaOpPoint, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaOpPoint)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaOpPoint_tp_dealloc(PyoaObserver_oaOpPointObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaOpPoint*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaOpPoint_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaOpPoint value;
    int convert_status=PyoaObserver_oaOpPoint_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaObserver_oaOpPoint::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaOpPoint_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaOpPoint v1;
    PyParamoaObserver_oaOpPoint v2;
    int convert_status1=PyoaObserver_oaOpPoint_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaOpPoint_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaOpPoint_Convert(PyObject* ob,PyParamoaObserver_oaOpPoint* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaOpPoint_Check(ob)) {
        result->SetData( (oaObserver_oaOpPoint*) ((PyoaObserver_oaOpPointObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaOpPoint Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaOpPoint_FromoaObserver_oaOpPoint(oaObserver_oaOpPoint* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaOpPoint_Type.tp_alloc(&PyoaObserver_oaOpPoint_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaOpPointObject* self = (PyoaObserver_oaOpPointObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaOpPoint::pyv_oaObserver_oaOpPoint(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaOpPoint(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaOpPoint::pyv_oaObserver_oaOpPoint(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaOpPoint(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaOpPoint::pyv_oaObserver_oaOpPoint(const oaObserver_oaOpPoint& p)
 : pyob(NULL),
   oaObserver_oaOpPoint(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaOpPoint::onPostCreate(oaOpPoint* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaOpPoint::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaOpPoint_FromoaOpPoint(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaOpPoint::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaOpPoint::onPostModify(oaOpPoint* p1,oaOpPointModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaOpPoint::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaOpPoint_FromoaOpPoint(p1));
    PyTuple_SetItem(args,1,PyoaOpPointModTypeEnum_FromoaOpPointModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaOpPoint::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaOpPoint::onPreDestroy(oaOpPoint* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaOpPoint::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaOpPoint_FromoaOpPoint(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaOpPoint::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaOpPoint::onPreModify(oaOpPoint* p1,oaOpPointModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaOpPoint::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaOpPoint_FromoaOpPoint(p1));
    PyTuple_SetItem(args,1,PyoaOpPointModTypeEnum_FromoaOpPointModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaOpPoint::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaOpPoint_doc[] = 
"Class: oaObserver_oaOpPoint\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaOpPoint(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaOpPoint||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaOpPoint\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaOpPoint(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaOpPoint||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaOpPoint\n"
"  Paramegers: (oaObserver_oaOpPoint)\n"
"    Calls: (const oaObserver_oaOpPoint&)\n"
"    Signature: oaObserver_oaOpPoint||cref-oaObserver_oaOpPoint,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaOpPoint_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaOpPoint",
    sizeof(PyoaObserver_oaOpPointObject),
    0,
    (destructor)oaObserver_oaOpPoint_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaOpPoint_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaOpPoint_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaOpPoint_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaOpPoint_oaOpPointModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaOpPoint_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaOpPoint_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaOpPoint_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaOpPoint\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaOpPoint",
           (PyObject*)(&PyoaObserver_oaOpPoint_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaOpPoint\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaOpPointHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaOpPointHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaOpPointHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaOpPointHeaderObject* self = (PyoaObserver_oaOpPointHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaOpPointHeader(p1.Data());
            }
            else {
                pyv_oaObserver_oaOpPointHeader* p=new pyv_oaObserver_oaOpPointHeader(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaOpPointHeader(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaOpPointHeader* p=new pyv_oaObserver_oaOpPointHeader(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaOpPointHeader)
    {
        PyParamoaObserver_oaOpPointHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaOpPointHeader_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaOpPointHeader(p1.Data());
            }
            else {
                pyv_oaObserver_oaOpPointHeader* p=new pyv_oaObserver_oaOpPointHeader(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaOpPointHeader, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaOpPointHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaOpPointHeader_tp_dealloc(PyoaObserver_oaOpPointHeaderObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaOpPointHeader*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaOpPointHeader_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaOpPointHeader value;
    int convert_status=PyoaObserver_oaOpPointHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[48];
    sprintf(buffer,"<oaObserver_oaOpPointHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaOpPointHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaOpPointHeader v1;
    PyParamoaObserver_oaOpPointHeader v2;
    int convert_status1=PyoaObserver_oaOpPointHeader_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaOpPointHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaOpPointHeader_Convert(PyObject* ob,PyParamoaObserver_oaOpPointHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaOpPointHeader_Check(ob)) {
        result->SetData( (oaObserver_oaOpPointHeader*) ((PyoaObserver_oaOpPointHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaOpPointHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaOpPointHeader_FromoaObserver_oaOpPointHeader(oaObserver_oaOpPointHeader* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaOpPointHeader_Type.tp_alloc(&PyoaObserver_oaOpPointHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaOpPointHeaderObject* self = (PyoaObserver_oaOpPointHeaderObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaOpPointHeader::pyv_oaObserver_oaOpPointHeader(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaOpPointHeader(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaOpPointHeader::pyv_oaObserver_oaOpPointHeader(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaOpPointHeader(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaOpPointHeader::pyv_oaObserver_oaOpPointHeader(const oaObserver_oaOpPointHeader& p)
 : pyob(NULL),
   oaObserver_oaOpPointHeader(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaOpPointHeader::onPostCreate(oaOpPointHeader* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaOpPointHeader::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaOpPointHeader_FromoaOpPointHeader(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaOpPointHeader::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaOpPointHeader::onPostModify(oaOpPointHeader* p1,oaOpPointHeaderModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaOpPointHeader::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaOpPointHeader_FromoaOpPointHeader(p1));
    PyTuple_SetItem(args,1,PyoaOpPointHeaderModTypeEnum_FromoaOpPointHeaderModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaOpPointHeader::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaOpPointHeader::onPreDestroy(oaOpPointHeader* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaOpPointHeader::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaOpPointHeader_FromoaOpPointHeader(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaOpPointHeader::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaOpPointHeader::onPreModify(oaOpPointHeader* p1,oaOpPointHeaderModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaOpPointHeader::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaOpPointHeader_FromoaOpPointHeader(p1));
    PyTuple_SetItem(args,1,PyoaOpPointHeaderModTypeEnum_FromoaOpPointHeaderModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaOpPointHeader::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaOpPointHeader_doc[] = 
"Class: oaObserver_oaOpPointHeader\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaOpPointHeader(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaOpPointHeader||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaOpPointHeader\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaOpPointHeader(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaOpPointHeader||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaOpPointHeader\n"
"  Paramegers: (oaObserver_oaOpPointHeader)\n"
"    Calls: (const oaObserver_oaOpPointHeader&)\n"
"    Signature: oaObserver_oaOpPointHeader||cref-oaObserver_oaOpPointHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaOpPointHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaOpPointHeader",
    sizeof(PyoaObserver_oaOpPointHeaderObject),
    0,
    (destructor)oaObserver_oaOpPointHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaOpPointHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaOpPointHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaOpPointHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaOpPointHeader_oaOpPointHeaderModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaOpPointHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaOpPointHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaOpPointHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaOpPointHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaOpPointHeader",
           (PyObject*)(&PyoaObserver_oaOpPointHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaOpPointHeader\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaPRBoundary
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPRBoundary_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaPRBoundary_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaPRBoundaryObject* self = (PyoaObserver_oaPRBoundaryObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPRBoundary(p1.Data());
            }
            else {
                pyv_oaObserver_oaPRBoundary* p=new pyv_oaObserver_oaPRBoundary(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPRBoundary(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaPRBoundary* p=new pyv_oaObserver_oaPRBoundary(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaPRBoundary)
    {
        PyParamoaObserver_oaPRBoundary p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaPRBoundary_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaPRBoundary(p1.Data());
            }
            else {
                pyv_oaObserver_oaPRBoundary* p=new pyv_oaObserver_oaPRBoundary(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaPRBoundary, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaPRBoundary)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaPRBoundary_tp_dealloc(PyoaObserver_oaPRBoundaryObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaPRBoundary*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPRBoundary_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaPRBoundary value;
    int convert_status=PyoaObserver_oaPRBoundary_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaObserver_oaPRBoundary::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaPRBoundary_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaPRBoundary v1;
    PyParamoaObserver_oaPRBoundary v2;
    int convert_status1=PyoaObserver_oaPRBoundary_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaPRBoundary_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaPRBoundary_Convert(PyObject* ob,PyParamoaObserver_oaPRBoundary* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaPRBoundary_Check(ob)) {
        result->SetData( (oaObserver_oaPRBoundary*) ((PyoaObserver_oaPRBoundaryObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaPRBoundary Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaPRBoundary_FromoaObserver_oaPRBoundary(oaObserver_oaPRBoundary* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaPRBoundary_Type.tp_alloc(&PyoaObserver_oaPRBoundary_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaPRBoundaryObject* self = (PyoaObserver_oaPRBoundaryObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaPRBoundary::pyv_oaObserver_oaPRBoundary(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaPRBoundary(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPRBoundary::pyv_oaObserver_oaPRBoundary(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaPRBoundary(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPRBoundary::pyv_oaObserver_oaPRBoundary(const oaObserver_oaPRBoundary& p)
 : pyob(NULL),
   oaObserver_oaPRBoundary(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPRBoundary::onPostCreate(oaPRBoundary* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPRBoundary::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPRBoundary_FromoaPRBoundary(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPRBoundary::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPRBoundary::onPostModify(oaPRBoundary* p1,oaBoundaryModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPRBoundary::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPRBoundary_FromoaPRBoundary(p1));
    PyTuple_SetItem(args,1,PyoaBoundaryModTypeEnum_FromoaBoundaryModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPRBoundary::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPRBoundary::onPreDestroy(oaPRBoundary* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPRBoundary::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPRBoundary_FromoaPRBoundary(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPRBoundary::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPRBoundary::onPreModify(oaPRBoundary* p1,oaBoundaryModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPRBoundary::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPRBoundary_FromoaPRBoundary(p1));
    PyTuple_SetItem(args,1,PyoaBoundaryModTypeEnum_FromoaBoundaryModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPRBoundary::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaPRBoundary_doc[] = 
"Class: oaObserver_oaPRBoundary\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaPRBoundary(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaPRBoundary||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPRBoundary\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaPRBoundary(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaPRBoundary||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPRBoundary\n"
"  Paramegers: (oaObserver_oaPRBoundary)\n"
"    Calls: (const oaObserver_oaPRBoundary&)\n"
"    Signature: oaObserver_oaPRBoundary||cref-oaObserver_oaPRBoundary,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaPRBoundary_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaPRBoundary",
    sizeof(PyoaObserver_oaPRBoundaryObject),
    0,
    (destructor)oaObserver_oaPRBoundary_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaPRBoundary_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaPRBoundary_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaPRBoundary_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaPRBoundary_oaBoundaryModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaPRBoundary_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaPRBoundary_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaPRBoundary_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaPRBoundary\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaPRBoundary",
           (PyObject*)(&PyoaObserver_oaPRBoundary_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaPRBoundary\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaParasiticNetwork
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaParasiticNetwork_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaParasiticNetwork_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaParasiticNetworkObject* self = (PyoaObserver_oaParasiticNetworkObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaParasiticNetwork(p1.Data());
            }
            else {
                pyv_oaObserver_oaParasiticNetwork* p=new pyv_oaObserver_oaParasiticNetwork(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaParasiticNetwork(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaParasiticNetwork* p=new pyv_oaObserver_oaParasiticNetwork(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaParasiticNetwork, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaParasiticNetwork_tp_dealloc(PyoaObserver_oaParasiticNetworkObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaParasiticNetwork*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaParasiticNetwork_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaParasiticNetwork value;
    int convert_status=PyoaObserver_oaParasiticNetwork_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[51];
    sprintf(buffer,"<oaObserver_oaParasiticNetwork::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaParasiticNetwork_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaParasiticNetwork v1;
    PyParamoaObserver_oaParasiticNetwork v2;
    int convert_status1=PyoaObserver_oaParasiticNetwork_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaParasiticNetwork_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaParasiticNetwork_Convert(PyObject* ob,PyParamoaObserver_oaParasiticNetwork* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaParasiticNetwork_Check(ob)) {
        result->SetData( (oaObserver_oaParasiticNetwork*) ((PyoaObserver_oaParasiticNetworkObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaParasiticNetwork Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaParasiticNetwork_FromoaObserver_oaParasiticNetwork(oaObserver_oaParasiticNetwork* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaParasiticNetwork_Type.tp_alloc(&PyoaObserver_oaParasiticNetwork_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaParasiticNetworkObject* self = (PyoaObserver_oaParasiticNetworkObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaParasiticNetwork::pyv_oaObserver_oaParasiticNetwork(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaParasiticNetwork(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaParasiticNetwork::pyv_oaObserver_oaParasiticNetwork(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaParasiticNetwork(p1,p2)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaParasiticNetwork::onPostCreate(oaParasiticNetwork* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaParasiticNetwork::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaParasiticNetwork_FromoaParasiticNetwork(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaParasiticNetwork::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaParasiticNetwork::onPostLoad(oaParasiticNetwork* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostLoad");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaParasiticNetwork::onPostLoad was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaParasiticNetwork_FromoaParasiticNetwork(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaParasiticNetwork::onPostLoad had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaParasiticNetwork::onPostModify(oaParasiticNetwork* p1,oaParasiticNetworkModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaParasiticNetwork::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaParasiticNetwork_FromoaParasiticNetwork(p1));
    PyTuple_SetItem(args,1,PyoaParasiticNetworkModTypeEnum_FromoaParasiticNetworkModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaParasiticNetwork::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaParasiticNetwork::onPreDestroy(oaParasiticNetwork* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaParasiticNetwork::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaParasiticNetwork_FromoaParasiticNetwork(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaParasiticNetwork::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaParasiticNetwork::onPreModify(oaParasiticNetwork* p1,oaParasiticNetworkModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaParasiticNetwork::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaParasiticNetwork_FromoaParasiticNetwork(p1));
    PyTuple_SetItem(args,1,PyoaParasiticNetworkModTypeEnum_FromoaParasiticNetworkModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaParasiticNetwork::onPreModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaParasiticNetwork::onPreUnload(oaParasiticNetwork* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreUnload");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaParasiticNetwork::onPreUnload was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaParasiticNetwork_FromoaParasiticNetwork(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaParasiticNetwork::onPreUnload had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaParasiticNetwork_onPostCreate_doc[] = 
"Class: oaObserver_oaParasiticNetwork, Function: onPostCreate\n"
"  Paramegers: (oaParasiticNetwork)\n"
"    Calls: virtual void onPostCreate(oaParasiticNetwork* pn)\n"
"    Signature: onPostCreate|void-void|ptr-oaParasiticNetwork,\n"
"    This function is called after an oaParasiticNetwork object is created. The application's derived observer class should implement this function to receive notification after an oaParasiticNetwork object is created.\n"
"    pn\n"
"    pointer to the created oaParasiticNetwork object\n"
;

static PyObject*
oaObserver_oaParasiticNetwork_onPostCreate(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaParasiticNetwork data;
    int convert_status=PyoaObserver_oaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaParasiticNetworkObject* self=(PyoaObserver_oaParasiticNetworkObject*)ob;

    PyParamoaParasiticNetwork p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaParasiticNetwork_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaParasiticNetwork::onPostCreate(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaParasiticNetwork_onPostLoad_doc[] = 
"Class: oaObserver_oaParasiticNetwork, Function: onPostLoad\n"
"  Paramegers: (oaParasiticNetwork)\n"
"    Calls: virtual void onPostLoad(oaParasiticNetwork* pn)\n"
"    Signature: onPostLoad|void-void|ptr-oaParasiticNetwork,\n"
"    This observer function is called after an oaParasiticNetwork has been loaded. The application's derived class should implement this function to receive notification after an oaParasiticNetwork object has been loaded.\n"
"    pn\n"
"    A pointer to the loaded oaParasiticNetwork object\n"
;

static PyObject*
oaObserver_oaParasiticNetwork_onPostLoad(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaParasiticNetwork data;
    int convert_status=PyoaObserver_oaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaParasiticNetworkObject* self=(PyoaObserver_oaParasiticNetworkObject*)ob;

    PyParamoaParasiticNetwork p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaParasiticNetwork_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaParasiticNetwork::onPostLoad(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaParasiticNetwork_onPostModify_doc[] = 
"Class: oaObserver_oaParasiticNetwork, Function: onPostModify\n"
"  Paramegers: (oaParasiticNetwork,oaParasiticNetworkModTypeEnum)\n"
"    Calls: virtual void onPostModify(oaParasiticNetwork* pn,oaParasiticNetworkModTypeEnum modType)\n"
"    Signature: onPostModify|void-void|ptr-oaParasiticNetwork,simple-oaParasiticNetworkModTypeEnum,\n"
"    This function is called after an oaParasiticNetwork object has been modified. The application's derived class should implement this function to receive notification after an oaParasiticNetwork object has been modified.\n"
"    pn\n"
"    A pointer to the modified oaParasiticNetwork object\n"
"    modType\n"
"    The type of modification that was made\n"
;

static PyObject*
oaObserver_oaParasiticNetwork_onPostModify(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaParasiticNetwork data;
    int convert_status=PyoaObserver_oaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaParasiticNetworkObject* self=(PyoaObserver_oaParasiticNetworkObject*)ob;

    PyParamoaParasiticNetwork p1;
    PyParamoaParasiticNetworkModTypeEnum p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaParasiticNetwork_Convert,&p1,
          &PyoaParasiticNetworkModTypeEnum_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaParasiticNetwork::onPostModify(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaParasiticNetwork_onPreDestroy_doc[] = 
"Class: oaObserver_oaParasiticNetwork, Function: onPreDestroy\n"
"  Paramegers: (oaParasiticNetwork)\n"
"    Calls: virtual void onPreDestroy(oaParasiticNetwork* pn)\n"
"    Signature: onPreDestroy|void-void|ptr-oaParasiticNetwork,\n"
"    This function is called before an oaParasiticNetwork object is destroyed. The application's derived observer class should implement this function to receive notification when an oaParasiticNetwork object is about to be destroyed.\n"
"    pn\n"
"    pointer to the oaParasiticNetwork object to be destroyed\n"
;

static PyObject*
oaObserver_oaParasiticNetwork_onPreDestroy(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaParasiticNetwork data;
    int convert_status=PyoaObserver_oaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaParasiticNetworkObject* self=(PyoaObserver_oaParasiticNetworkObject*)ob;

    PyParamoaParasiticNetwork p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaParasiticNetwork_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaParasiticNetwork::onPreDestroy(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaParasiticNetwork_onPreModify_doc[] = 
"Class: oaObserver_oaParasiticNetwork, Function: onPreModify\n"
"  Paramegers: (oaParasiticNetwork,oaParasiticNetworkModTypeEnum)\n"
"    Calls: virtual void onPreModify(oaParasiticNetwork* pn,oaParasiticNetworkModTypeEnum modType)\n"
"    Signature: onPreModify|void-void|ptr-oaParasiticNetwork,simple-oaParasiticNetworkModTypeEnum,\n"
"    This function is called before an oaParasiticNetwork object is modified. The application's derived class should implement this function to receive notification when an oaParasiticNetwork object is about to be modified.\n"
"    pn\n"
"    A pointer to the oaParasiticNetwork object to be modified\n"
"    modType\n"
"    The type of modification to be made\n"
;

static PyObject*
oaObserver_oaParasiticNetwork_onPreModify(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaParasiticNetwork data;
    int convert_status=PyoaObserver_oaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaParasiticNetworkObject* self=(PyoaObserver_oaParasiticNetworkObject*)ob;

    PyParamoaParasiticNetwork p1;
    PyParamoaParasiticNetworkModTypeEnum p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaParasiticNetwork_Convert,&p1,
          &PyoaParasiticNetworkModTypeEnum_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaParasiticNetwork::onPreModify(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaParasiticNetwork_onPreUnload_doc[] = 
"Class: oaObserver_oaParasiticNetwork, Function: onPreUnload\n"
"  Paramegers: (oaParasiticNetwork)\n"
"    Calls: virtual void onPreUnload(oaParasiticNetwork* pn)\n"
"    Signature: onPreUnload|void-void|ptr-oaParasiticNetwork,\n"
"    This observer function is called before an oaParasiticNetwork is unloaded. The application's derived class should implement this function to receive notification when an oaParasiticNetwork object is about to be unloaded.\n"
"    pn\n"
"    A pointer to the oaParasiticNetwork object to be unloaded\n"
;

static PyObject*
oaObserver_oaParasiticNetwork_onPreUnload(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaParasiticNetwork data;
    int convert_status=PyoaObserver_oaParasiticNetwork_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaParasiticNetworkObject* self=(PyoaObserver_oaParasiticNetworkObject*)ob;

    PyParamoaParasiticNetwork p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaParasiticNetwork_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaParasiticNetwork::onPreUnload(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaObserver_oaParasiticNetwork_assign_doc[] = 
"Class: oaObserver_oaParasiticNetwork, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaObserver_oaParasiticNetwork_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaObserver_oaParasiticNetwork data;
  int convert_status=PyoaObserver_oaParasiticNetwork_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaObserver_oaParasiticNetwork p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaObserver_oaParasiticNetwork_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaObserver_oaParasiticNetwork_methodlist[] = {
    {"onPostCreate",(PyCFunction)oaObserver_oaParasiticNetwork_onPostCreate,METH_VARARGS,oaObserver_oaParasiticNetwork_onPostCreate_doc},
    {"onPostLoad",(PyCFunction)oaObserver_oaParasiticNetwork_onPostLoad,METH_VARARGS,oaObserver_oaParasiticNetwork_onPostLoad_doc},
    {"onPostModify",(PyCFunction)oaObserver_oaParasiticNetwork_onPostModify,METH_VARARGS,oaObserver_oaParasiticNetwork_onPostModify_doc},
    {"onPreDestroy",(PyCFunction)oaObserver_oaParasiticNetwork_onPreDestroy,METH_VARARGS,oaObserver_oaParasiticNetwork_onPreDestroy_doc},
    {"onPreModify",(PyCFunction)oaObserver_oaParasiticNetwork_onPreModify,METH_VARARGS,oaObserver_oaParasiticNetwork_onPreModify_doc},
    {"onPreUnload",(PyCFunction)oaObserver_oaParasiticNetwork_onPreUnload,METH_VARARGS,oaObserver_oaParasiticNetwork_onPreUnload_doc},
    {"assign",(PyCFunction)oaObserver_oaParasiticNetwork_tp_assign,METH_VARARGS,oaObserver_oaParasiticNetwork_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaParasiticNetwork_doc[] = 
"Class: oaObserver_oaParasiticNetwork\n"
"  This base template class can be used to derive observers for oaParasiticNetwork objects. It supports postCreate, preDestroy, postLoad, preUnload, preModify, and postModify event notifications.\n"
"  See oaObserver for information on using Open Access observer template classes to derive and instantiate observers in an application.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaParasiticNetwork(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaParasiticNetwork||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaParasiticNetwork\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaParasiticNetwork(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaParasiticNetwork||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaParasiticNetwork\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaParasiticNetwork_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaParasiticNetwork",
    sizeof(PyoaObserver_oaParasiticNetworkObject),
    0,
    (destructor)oaObserver_oaParasiticNetwork_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaParasiticNetwork_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaParasiticNetwork_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaParasiticNetwork_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaObserver_oaParasiticNetwork_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBaseObserver_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaParasiticNetwork_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaParasiticNetwork_static_notifyPostCreateObservers_doc[] = 
"Class: oaObserver_oaParasiticNetwork, Function: notifyPostCreateObservers\n"
"  Paramegers: (oaParasiticNetwork)\n"
"    Calls: void notifyPostCreateObservers(oaParasiticNetwork* pn)\n"
"    Signature: notifyPostCreateObservers|void-void|ptr-oaParasiticNetwork,\n"
"    Function notifyPostCreateObservers\n"
;

static PyObject*
oaObserver_oaParasiticNetwork_static_notifyPostCreateObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaParasiticNetwork_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaParasiticNetwork::notifyPostCreateObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaParasiticNetwork_static_notifyPostLoadObservers_doc[] = 
"Class: oaObserver_oaParasiticNetwork, Function: notifyPostLoadObservers\n"
"  Paramegers: (oaParasiticNetwork)\n"
"    Calls: void notifyPostLoadObservers(oaParasiticNetwork* pn)\n"
"    Signature: notifyPostLoadObservers|void-void|ptr-oaParasiticNetwork,\n"
"    Function notifyPostLoadObservers\n"
;

static PyObject*
oaObserver_oaParasiticNetwork_static_notifyPostLoadObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaParasiticNetwork_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaParasiticNetwork::notifyPostLoadObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaParasiticNetwork_static_notifyPostModifyObservers_doc[] = 
"Class: oaObserver_oaParasiticNetwork, Function: notifyPostModifyObservers\n"
"  Paramegers: (oaParasiticNetwork,oaParasiticNetworkModTypeEnum)\n"
"    Calls: void notifyPostModifyObservers(oaParasiticNetwork* pn,oaParasiticNetworkModTypeEnum mt)\n"
"    Signature: notifyPostModifyObservers|void-void|ptr-oaParasiticNetwork,simple-oaParasiticNetworkModTypeEnum,\n"
"    Function notifyPostModifyObservers\n"
;

static PyObject*
oaObserver_oaParasiticNetwork_static_notifyPostModifyObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork p1;
    PyParamoaParasiticNetworkModTypeEnum p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaParasiticNetwork_Convert,&p1,
          &PyoaParasiticNetworkModTypeEnum_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaParasiticNetwork::notifyPostModifyObservers(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaParasiticNetwork_static_notifyPreDestroyObservers_doc[] = 
"Class: oaObserver_oaParasiticNetwork, Function: notifyPreDestroyObservers\n"
"  Paramegers: (oaParasiticNetwork)\n"
"    Calls: void notifyPreDestroyObservers(oaParasiticNetwork* pn)\n"
"    Signature: notifyPreDestroyObservers|void-void|ptr-oaParasiticNetwork,\n"
"    Function notifyPreDestroyObservers\n"
;

static PyObject*
oaObserver_oaParasiticNetwork_static_notifyPreDestroyObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaParasiticNetwork_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaParasiticNetwork::notifyPreDestroyObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaParasiticNetwork_static_notifyPreModifyObservers_doc[] = 
"Class: oaObserver_oaParasiticNetwork, Function: notifyPreModifyObservers\n"
"  Paramegers: (oaParasiticNetwork,oaParasiticNetworkModTypeEnum)\n"
"    Calls: void notifyPreModifyObservers(oaParasiticNetwork* pn,oaParasiticNetworkModTypeEnum mt)\n"
"    Signature: notifyPreModifyObservers|void-void|ptr-oaParasiticNetwork,simple-oaParasiticNetworkModTypeEnum,\n"
"    Function notifyPreModifyObservers\n"
;

static PyObject*
oaObserver_oaParasiticNetwork_static_notifyPreModifyObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork p1;
    PyParamoaParasiticNetworkModTypeEnum p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaParasiticNetwork_Convert,&p1,
          &PyoaParasiticNetworkModTypeEnum_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaParasiticNetwork::notifyPreModifyObservers(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaParasiticNetwork_static_notifyPreUnloadObservers_doc[] = 
"Class: oaObserver_oaParasiticNetwork, Function: notifyPreUnloadObservers\n"
"  Paramegers: (oaParasiticNetwork)\n"
"    Calls: void notifyPreUnloadObservers(oaParasiticNetwork* pn)\n"
"    Signature: notifyPreUnloadObservers|void-void|ptr-oaParasiticNetwork,\n"
"    Function notifyPreUnloadObservers\n"
;

static PyObject*
oaObserver_oaParasiticNetwork_static_notifyPreUnloadObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaParasiticNetwork p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaParasiticNetwork_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaParasiticNetwork::notifyPreUnloadObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaObserver_oaParasiticNetwork_staticmethodlist[] = {
    {"static_notifyPostCreateObservers",(PyCFunction)oaObserver_oaParasiticNetwork_static_notifyPostCreateObservers,METH_VARARGS,oaObserver_oaParasiticNetwork_static_notifyPostCreateObservers_doc},
    {"static_notifyPostLoadObservers",(PyCFunction)oaObserver_oaParasiticNetwork_static_notifyPostLoadObservers,METH_VARARGS,oaObserver_oaParasiticNetwork_static_notifyPostLoadObservers_doc},
    {"static_notifyPostModifyObservers",(PyCFunction)oaObserver_oaParasiticNetwork_static_notifyPostModifyObservers,METH_VARARGS,oaObserver_oaParasiticNetwork_static_notifyPostModifyObservers_doc},
    {"static_notifyPreDestroyObservers",(PyCFunction)oaObserver_oaParasiticNetwork_static_notifyPreDestroyObservers,METH_VARARGS,oaObserver_oaParasiticNetwork_static_notifyPreDestroyObservers_doc},
    {"static_notifyPreModifyObservers",(PyCFunction)oaObserver_oaParasiticNetwork_static_notifyPreModifyObservers,METH_VARARGS,oaObserver_oaParasiticNetwork_static_notifyPreModifyObservers_doc},
    {"static_notifyPreUnloadObservers",(PyCFunction)oaObserver_oaParasiticNetwork_static_notifyPreUnloadObservers,METH_VARARGS,oaObserver_oaParasiticNetwork_static_notifyPreUnloadObservers_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaParasiticNetwork_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaParasiticNetwork_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaParasiticNetwork\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaParasiticNetwork",
           (PyObject*)(&PyoaObserver_oaParasiticNetwork_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaParasiticNetwork\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaObserver_oaParasiticNetwork_Type.tp_dict;
    for(method=oaObserver_oaParasiticNetwork_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaPath
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPath_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaPath_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaPathObject* self = (PyoaObserver_oaPathObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPath(p1.Data());
            }
            else {
                pyv_oaObserver_oaPath* p=new pyv_oaObserver_oaPath(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPath(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaPath* p=new pyv_oaObserver_oaPath(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaPath)
    {
        PyParamoaObserver_oaPath p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaPath_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaPath(p1.Data());
            }
            else {
                pyv_oaObserver_oaPath* p=new pyv_oaObserver_oaPath(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaPath, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaPath)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaPath_tp_dealloc(PyoaObserver_oaPathObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaPath*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPath_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaPath value;
    int convert_status=PyoaObserver_oaPath_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[39];
    sprintf(buffer,"<oaObserver_oaPath::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaPath_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaPath v1;
    PyParamoaObserver_oaPath v2;
    int convert_status1=PyoaObserver_oaPath_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaPath_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaPath_Convert(PyObject* ob,PyParamoaObserver_oaPath* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaPath_Check(ob)) {
        result->SetData( (oaObserver_oaPath*) ((PyoaObserver_oaPathObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaPath Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaPath_FromoaObserver_oaPath(oaObserver_oaPath* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaPath_Type.tp_alloc(&PyoaObserver_oaPath_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaPathObject* self = (PyoaObserver_oaPathObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaPath::pyv_oaObserver_oaPath(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaPath(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPath::pyv_oaObserver_oaPath(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaPath(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPath::pyv_oaObserver_oaPath(const oaObserver_oaPath& p)
 : pyob(NULL),
   oaObserver_oaPath(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPath::onPostCreate(oaPath* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPath::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPath_FromoaPath(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPath::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPath::onPostModify(oaPath* p1,oaShapeModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPath::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPath_FromoaPath(p1));
    PyTuple_SetItem(args,1,PyoaShapeModTypeEnum_FromoaShapeModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPath::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPath::onPreDestroy(oaPath* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPath::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPath_FromoaPath(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPath::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPath::onPreModify(oaPath* p1,oaShapeModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPath::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPath_FromoaPath(p1));
    PyTuple_SetItem(args,1,PyoaShapeModTypeEnum_FromoaShapeModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPath::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaPath_doc[] = 
"Class: oaObserver_oaPath\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaPath(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaPath||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPath\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaPath(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaPath||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPath\n"
"  Paramegers: (oaObserver_oaPath)\n"
"    Calls: (const oaObserver_oaPath&)\n"
"    Signature: oaObserver_oaPath||cref-oaObserver_oaPath,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaPath_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaPath",
    sizeof(PyoaObserver_oaPathObject),
    0,
    (destructor)oaObserver_oaPath_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaPath_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaPath_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaPath_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaPath_oaShapeModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaPath_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaPath_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaPath_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaPath\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaPath",
           (PyObject*)(&PyoaObserver_oaPath_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaPath\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaPathSeg
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPathSeg_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaPathSeg_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaPathSegObject* self = (PyoaObserver_oaPathSegObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPathSeg(p1.Data());
            }
            else {
                pyv_oaObserver_oaPathSeg* p=new pyv_oaObserver_oaPathSeg(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPathSeg(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaPathSeg* p=new pyv_oaObserver_oaPathSeg(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaPathSeg)
    {
        PyParamoaObserver_oaPathSeg p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaPathSeg_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaPathSeg(p1.Data());
            }
            else {
                pyv_oaObserver_oaPathSeg* p=new pyv_oaObserver_oaPathSeg(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaPathSeg, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaPathSeg)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaPathSeg_tp_dealloc(PyoaObserver_oaPathSegObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaPathSeg*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPathSeg_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaPathSeg value;
    int convert_status=PyoaObserver_oaPathSeg_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaObserver_oaPathSeg::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaPathSeg_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaPathSeg v1;
    PyParamoaObserver_oaPathSeg v2;
    int convert_status1=PyoaObserver_oaPathSeg_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaPathSeg_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaPathSeg_Convert(PyObject* ob,PyParamoaObserver_oaPathSeg* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaPathSeg_Check(ob)) {
        result->SetData( (oaObserver_oaPathSeg*) ((PyoaObserver_oaPathSegObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaPathSeg Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaPathSeg_FromoaObserver_oaPathSeg(oaObserver_oaPathSeg* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaPathSeg_Type.tp_alloc(&PyoaObserver_oaPathSeg_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaPathSegObject* self = (PyoaObserver_oaPathSegObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaPathSeg::pyv_oaObserver_oaPathSeg(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaPathSeg(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPathSeg::pyv_oaObserver_oaPathSeg(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaPathSeg(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPathSeg::pyv_oaObserver_oaPathSeg(const oaObserver_oaPathSeg& p)
 : pyob(NULL),
   oaObserver_oaPathSeg(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPathSeg::onPostCreate(oaPathSeg* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPathSeg::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPathSeg_FromoaPathSeg(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPathSeg::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPathSeg::onPostModify(oaPathSeg* p1,oaShapeModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPathSeg::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPathSeg_FromoaPathSeg(p1));
    PyTuple_SetItem(args,1,PyoaShapeModTypeEnum_FromoaShapeModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPathSeg::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPathSeg::onPreDestroy(oaPathSeg* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPathSeg::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPathSeg_FromoaPathSeg(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPathSeg::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPathSeg::onPreModify(oaPathSeg* p1,oaShapeModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPathSeg::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPathSeg_FromoaPathSeg(p1));
    PyTuple_SetItem(args,1,PyoaShapeModTypeEnum_FromoaShapeModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPathSeg::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaPathSeg_doc[] = 
"Class: oaObserver_oaPathSeg\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaPathSeg(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaPathSeg||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPathSeg\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaPathSeg(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaPathSeg||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPathSeg\n"
"  Paramegers: (oaObserver_oaPathSeg)\n"
"    Calls: (const oaObserver_oaPathSeg&)\n"
"    Signature: oaObserver_oaPathSeg||cref-oaObserver_oaPathSeg,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaPathSeg_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaPathSeg",
    sizeof(PyoaObserver_oaPathSegObject),
    0,
    (destructor)oaObserver_oaPathSeg_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaPathSeg_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaPathSeg_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaPathSeg_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaPathSeg_oaShapeModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaPathSeg_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaPathSeg_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaPathSeg_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaPathSeg\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaPathSeg",
           (PyObject*)(&PyoaObserver_oaPathSeg_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaPathSeg\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaPhysicalLayer
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPhysicalLayer_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaPhysicalLayer_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaPhysicalLayerObject* self = (PyoaObserver_oaPhysicalLayerObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPhysicalLayer(p1.Data());
            }
            else {
                pyv_oaObserver_oaPhysicalLayer* p=new pyv_oaObserver_oaPhysicalLayer(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPhysicalLayer(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaPhysicalLayer* p=new pyv_oaObserver_oaPhysicalLayer(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaPhysicalLayer)
    {
        PyParamoaObserver_oaPhysicalLayer p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaPhysicalLayer_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaPhysicalLayer(p1.Data());
            }
            else {
                pyv_oaObserver_oaPhysicalLayer* p=new pyv_oaObserver_oaPhysicalLayer(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaPhysicalLayer, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaPhysicalLayer)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaPhysicalLayer_tp_dealloc(PyoaObserver_oaPhysicalLayerObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaPhysicalLayer*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPhysicalLayer_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaPhysicalLayer value;
    int convert_status=PyoaObserver_oaPhysicalLayer_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[48];
    sprintf(buffer,"<oaObserver_oaPhysicalLayer::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaPhysicalLayer_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaPhysicalLayer v1;
    PyParamoaObserver_oaPhysicalLayer v2;
    int convert_status1=PyoaObserver_oaPhysicalLayer_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaPhysicalLayer_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaPhysicalLayer_Convert(PyObject* ob,PyParamoaObserver_oaPhysicalLayer* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaPhysicalLayer_Check(ob)) {
        result->SetData( (oaObserver_oaPhysicalLayer*) ((PyoaObserver_oaPhysicalLayerObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaPhysicalLayer Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaPhysicalLayer_FromoaObserver_oaPhysicalLayer(oaObserver_oaPhysicalLayer* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaPhysicalLayer_Type.tp_alloc(&PyoaObserver_oaPhysicalLayer_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaPhysicalLayerObject* self = (PyoaObserver_oaPhysicalLayerObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaPhysicalLayer::pyv_oaObserver_oaPhysicalLayer(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaPhysicalLayer(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPhysicalLayer::pyv_oaObserver_oaPhysicalLayer(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaPhysicalLayer(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPhysicalLayer::pyv_oaObserver_oaPhysicalLayer(const oaObserver_oaPhysicalLayer& p)
 : pyob(NULL),
   oaObserver_oaPhysicalLayer(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPhysicalLayer::onPostCreate(oaPhysicalLayer* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPhysicalLayer::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPhysicalLayer_FromoaPhysicalLayer(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPhysicalLayer::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPhysicalLayer::onPostModify(oaPhysicalLayer* p1,oaLayerModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPhysicalLayer::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPhysicalLayer_FromoaPhysicalLayer(p1));
    PyTuple_SetItem(args,1,PyoaLayerModTypeEnum_FromoaLayerModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPhysicalLayer::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPhysicalLayer::onPreDestroy(oaPhysicalLayer* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPhysicalLayer::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPhysicalLayer_FromoaPhysicalLayer(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPhysicalLayer::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPhysicalLayer::onPreModify(oaPhysicalLayer* p1,oaLayerModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPhysicalLayer::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPhysicalLayer_FromoaPhysicalLayer(p1));
    PyTuple_SetItem(args,1,PyoaLayerModTypeEnum_FromoaLayerModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPhysicalLayer::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaPhysicalLayer_doc[] = 
"Class: oaObserver_oaPhysicalLayer\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaPhysicalLayer(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaPhysicalLayer||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPhysicalLayer\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaPhysicalLayer(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaPhysicalLayer||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPhysicalLayer\n"
"  Paramegers: (oaObserver_oaPhysicalLayer)\n"
"    Calls: (const oaObserver_oaPhysicalLayer&)\n"
"    Signature: oaObserver_oaPhysicalLayer||cref-oaObserver_oaPhysicalLayer,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaPhysicalLayer_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaPhysicalLayer",
    sizeof(PyoaObserver_oaPhysicalLayerObject),
    0,
    (destructor)oaObserver_oaPhysicalLayer_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaPhysicalLayer_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaPhysicalLayer_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaPhysicalLayer_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaPhysicalLayer_oaLayerModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaPhysicalLayer_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaPhysicalLayer_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaPhysicalLayer_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaPhysicalLayer\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaPhysicalLayer",
           (PyObject*)(&PyoaObserver_oaPhysicalLayer_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaPhysicalLayer\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaPiElmore
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPiElmore_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaPiElmore_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaPiElmoreObject* self = (PyoaObserver_oaPiElmoreObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPiElmore(p1.Data());
            }
            else {
                pyv_oaObserver_oaPiElmore* p=new pyv_oaObserver_oaPiElmore(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPiElmore(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaPiElmore* p=new pyv_oaObserver_oaPiElmore(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaPiElmore)
    {
        PyParamoaObserver_oaPiElmore p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaPiElmore_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaPiElmore(p1.Data());
            }
            else {
                pyv_oaObserver_oaPiElmore* p=new pyv_oaObserver_oaPiElmore(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaPiElmore, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaPiElmore)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaPiElmore_tp_dealloc(PyoaObserver_oaPiElmoreObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaPiElmore*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPiElmore_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaPiElmore value;
    int convert_status=PyoaObserver_oaPiElmore_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaObserver_oaPiElmore::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaPiElmore_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaPiElmore v1;
    PyParamoaObserver_oaPiElmore v2;
    int convert_status1=PyoaObserver_oaPiElmore_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaPiElmore_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaPiElmore_Convert(PyObject* ob,PyParamoaObserver_oaPiElmore* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaPiElmore_Check(ob)) {
        result->SetData( (oaObserver_oaPiElmore*) ((PyoaObserver_oaPiElmoreObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaPiElmore Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaPiElmore_FromoaObserver_oaPiElmore(oaObserver_oaPiElmore* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaPiElmore_Type.tp_alloc(&PyoaObserver_oaPiElmore_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaPiElmoreObject* self = (PyoaObserver_oaPiElmoreObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaPiElmore::pyv_oaObserver_oaPiElmore(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaPiElmore(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPiElmore::pyv_oaObserver_oaPiElmore(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaPiElmore(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPiElmore::pyv_oaObserver_oaPiElmore(const oaObserver_oaPiElmore& p)
 : pyob(NULL),
   oaObserver_oaPiElmore(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPiElmore::onPostCreate(oaPiElmore* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPiElmore::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPiElmore_FromoaPiElmore(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPiElmore::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPiElmore::onPostModify(oaPiElmore* p1,oaReducedModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPiElmore::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPiElmore_FromoaPiElmore(p1));
    PyTuple_SetItem(args,1,PyoaReducedModTypeEnum_FromoaReducedModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPiElmore::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPiElmore::onPreDestroy(oaPiElmore* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPiElmore::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPiElmore_FromoaPiElmore(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPiElmore::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPiElmore::onPreModify(oaPiElmore* p1,oaReducedModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPiElmore::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPiElmore_FromoaPiElmore(p1));
    PyTuple_SetItem(args,1,PyoaReducedModTypeEnum_FromoaReducedModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPiElmore::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaPiElmore_doc[] = 
"Class: oaObserver_oaPiElmore\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaPiElmore(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaPiElmore||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPiElmore\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaPiElmore(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaPiElmore||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPiElmore\n"
"  Paramegers: (oaObserver_oaPiElmore)\n"
"    Calls: (const oaObserver_oaPiElmore&)\n"
"    Signature: oaObserver_oaPiElmore||cref-oaObserver_oaPiElmore,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaPiElmore_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaPiElmore",
    sizeof(PyoaObserver_oaPiElmoreObject),
    0,
    (destructor)oaObserver_oaPiElmore_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaPiElmore_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaPiElmore_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaPiElmore_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaPiElmore_oaReducedModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaPiElmore_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaPiElmore_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaPiElmore_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaPiElmore\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaPiElmore",
           (PyObject*)(&PyoaObserver_oaPiElmore_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaPiElmore\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaPiPoleResidue
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPiPoleResidue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaPiPoleResidue_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaPiPoleResidueObject* self = (PyoaObserver_oaPiPoleResidueObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPiPoleResidue(p1.Data());
            }
            else {
                pyv_oaObserver_oaPiPoleResidue* p=new pyv_oaObserver_oaPiPoleResidue(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPiPoleResidue(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaPiPoleResidue* p=new pyv_oaObserver_oaPiPoleResidue(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaPiPoleResidue)
    {
        PyParamoaObserver_oaPiPoleResidue p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaPiPoleResidue_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaPiPoleResidue(p1.Data());
            }
            else {
                pyv_oaObserver_oaPiPoleResidue* p=new pyv_oaObserver_oaPiPoleResidue(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaPiPoleResidue, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaPiPoleResidue)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaPiPoleResidue_tp_dealloc(PyoaObserver_oaPiPoleResidueObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaPiPoleResidue*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPiPoleResidue_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaPiPoleResidue value;
    int convert_status=PyoaObserver_oaPiPoleResidue_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[48];
    sprintf(buffer,"<oaObserver_oaPiPoleResidue::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaPiPoleResidue_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaPiPoleResidue v1;
    PyParamoaObserver_oaPiPoleResidue v2;
    int convert_status1=PyoaObserver_oaPiPoleResidue_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaPiPoleResidue_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaPiPoleResidue_Convert(PyObject* ob,PyParamoaObserver_oaPiPoleResidue* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaPiPoleResidue_Check(ob)) {
        result->SetData( (oaObserver_oaPiPoleResidue*) ((PyoaObserver_oaPiPoleResidueObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaPiPoleResidue Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaPiPoleResidue_FromoaObserver_oaPiPoleResidue(oaObserver_oaPiPoleResidue* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaPiPoleResidue_Type.tp_alloc(&PyoaObserver_oaPiPoleResidue_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaPiPoleResidueObject* self = (PyoaObserver_oaPiPoleResidueObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaPiPoleResidue::pyv_oaObserver_oaPiPoleResidue(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaPiPoleResidue(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPiPoleResidue::pyv_oaObserver_oaPiPoleResidue(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaPiPoleResidue(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPiPoleResidue::pyv_oaObserver_oaPiPoleResidue(const oaObserver_oaPiPoleResidue& p)
 : pyob(NULL),
   oaObserver_oaPiPoleResidue(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPiPoleResidue::onPostCreate(oaPiPoleResidue* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPiPoleResidue::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPiPoleResidue_FromoaPiPoleResidue(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPiPoleResidue::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPiPoleResidue::onPostModify(oaPiPoleResidue* p1,oaReducedModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPiPoleResidue::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPiPoleResidue_FromoaPiPoleResidue(p1));
    PyTuple_SetItem(args,1,PyoaReducedModTypeEnum_FromoaReducedModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPiPoleResidue::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPiPoleResidue::onPreDestroy(oaPiPoleResidue* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPiPoleResidue::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPiPoleResidue_FromoaPiPoleResidue(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPiPoleResidue::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPiPoleResidue::onPreModify(oaPiPoleResidue* p1,oaReducedModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPiPoleResidue::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPiPoleResidue_FromoaPiPoleResidue(p1));
    PyTuple_SetItem(args,1,PyoaReducedModTypeEnum_FromoaReducedModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPiPoleResidue::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaPiPoleResidue_doc[] = 
"Class: oaObserver_oaPiPoleResidue\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaPiPoleResidue(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaPiPoleResidue||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPiPoleResidue\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaPiPoleResidue(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaPiPoleResidue||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPiPoleResidue\n"
"  Paramegers: (oaObserver_oaPiPoleResidue)\n"
"    Calls: (const oaObserver_oaPiPoleResidue&)\n"
"    Signature: oaObserver_oaPiPoleResidue||cref-oaObserver_oaPiPoleResidue,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaPiPoleResidue_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaPiPoleResidue",
    sizeof(PyoaObserver_oaPiPoleResidueObject),
    0,
    (destructor)oaObserver_oaPiPoleResidue_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaPiPoleResidue_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaPiPoleResidue_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaPiPoleResidue_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaPiPoleResidue_oaReducedModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaPiPoleResidue_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaPiPoleResidue_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaPiPoleResidue_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaPiPoleResidue\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaPiPoleResidue",
           (PyObject*)(&PyoaObserver_oaPiPoleResidue_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaPiPoleResidue\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaPin
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPin_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaPin_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaPinObject* self = (PyoaObserver_oaPinObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPin(p1.Data());
            }
            else {
                pyv_oaObserver_oaPin* p=new pyv_oaObserver_oaPin(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPin(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaPin* p=new pyv_oaObserver_oaPin(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaPin)
    {
        PyParamoaObserver_oaPin p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaPin_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaPin(p1.Data());
            }
            else {
                pyv_oaObserver_oaPin* p=new pyv_oaObserver_oaPin(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaPin, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaPin)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaPin_tp_dealloc(PyoaObserver_oaPinObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaPin*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPin_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaPin value;
    int convert_status=PyoaObserver_oaPin_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[38];
    sprintf(buffer,"<oaObserver_oaPin::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaPin_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaPin v1;
    PyParamoaObserver_oaPin v2;
    int convert_status1=PyoaObserver_oaPin_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaPin_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaPin_Convert(PyObject* ob,PyParamoaObserver_oaPin* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaPin_Check(ob)) {
        result->SetData( (oaObserver_oaPin*) ((PyoaObserver_oaPinObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaPin Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaPin_FromoaObserver_oaPin(oaObserver_oaPin* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaPin_Type.tp_alloc(&PyoaObserver_oaPin_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaPinObject* self = (PyoaObserver_oaPinObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaPin::pyv_oaObserver_oaPin(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaPin(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPin::pyv_oaObserver_oaPin(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaPin(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPin::pyv_oaObserver_oaPin(const oaObserver_oaPin& p)
 : pyob(NULL),
   oaObserver_oaPin(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPin::onPostCreate(oaPin* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPin::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPin_FromoaPin(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPin::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPin::onPostModify(oaPin* p1,oaPinModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPin::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPin_FromoaPin(p1));
    PyTuple_SetItem(args,1,PyoaPinModTypeEnum_FromoaPinModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPin::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPin::onPreDestroy(oaPin* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPin::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPin_FromoaPin(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPin::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPin::onPreModify(oaPin* p1,oaPinModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPin::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPin_FromoaPin(p1));
    PyTuple_SetItem(args,1,PyoaPinModTypeEnum_FromoaPinModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPin::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaPin_doc[] = 
"Class: oaObserver_oaPin\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaPin(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaPin||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPin\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaPin(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaPin||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPin\n"
"  Paramegers: (oaObserver_oaPin)\n"
"    Calls: (const oaObserver_oaPin&)\n"
"    Signature: oaObserver_oaPin||cref-oaObserver_oaPin,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaPin_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaPin",
    sizeof(PyoaObserver_oaPinObject),
    0,
    (destructor)oaObserver_oaPin_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaPin_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaPin_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaPin_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaPin_oaPinModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaPin_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaPin_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaPin_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaPin\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaPin",
           (PyObject*)(&PyoaObserver_oaPin_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaPin\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaPoleResidue
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPoleResidue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaPoleResidue_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaPoleResidueObject* self = (PyoaObserver_oaPoleResidueObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPoleResidue(p1.Data());
            }
            else {
                pyv_oaObserver_oaPoleResidue* p=new pyv_oaObserver_oaPoleResidue(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPoleResidue(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaPoleResidue* p=new pyv_oaObserver_oaPoleResidue(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaPoleResidue)
    {
        PyParamoaObserver_oaPoleResidue p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaPoleResidue_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaPoleResidue(p1.Data());
            }
            else {
                pyv_oaObserver_oaPoleResidue* p=new pyv_oaObserver_oaPoleResidue(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaPoleResidue, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaPoleResidue)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaPoleResidue_tp_dealloc(PyoaObserver_oaPoleResidueObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaPoleResidue*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPoleResidue_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaPoleResidue value;
    int convert_status=PyoaObserver_oaPoleResidue_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaObserver_oaPoleResidue::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaPoleResidue_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaPoleResidue v1;
    PyParamoaObserver_oaPoleResidue v2;
    int convert_status1=PyoaObserver_oaPoleResidue_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaPoleResidue_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaPoleResidue_Convert(PyObject* ob,PyParamoaObserver_oaPoleResidue* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaPoleResidue_Check(ob)) {
        result->SetData( (oaObserver_oaPoleResidue*) ((PyoaObserver_oaPoleResidueObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaPoleResidue Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaPoleResidue_FromoaObserver_oaPoleResidue(oaObserver_oaPoleResidue* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaPoleResidue_Type.tp_alloc(&PyoaObserver_oaPoleResidue_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaPoleResidueObject* self = (PyoaObserver_oaPoleResidueObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaPoleResidue::pyv_oaObserver_oaPoleResidue(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaPoleResidue(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPoleResidue::pyv_oaObserver_oaPoleResidue(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaPoleResidue(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPoleResidue::pyv_oaObserver_oaPoleResidue(const oaObserver_oaPoleResidue& p)
 : pyob(NULL),
   oaObserver_oaPoleResidue(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPoleResidue::onPostCreate(oaPoleResidue* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPoleResidue::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPoleResidue_FromoaPoleResidue(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPoleResidue::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPoleResidue::onPostModify(oaPoleResidue* p1,oaPoleResidueModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPoleResidue::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPoleResidue_FromoaPoleResidue(p1));
    PyTuple_SetItem(args,1,PyoaPoleResidueModTypeEnum_FromoaPoleResidueModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPoleResidue::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPoleResidue::onPreDestroy(oaPoleResidue* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPoleResidue::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPoleResidue_FromoaPoleResidue(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPoleResidue::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPoleResidue::onPreModify(oaPoleResidue* p1,oaPoleResidueModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPoleResidue::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPoleResidue_FromoaPoleResidue(p1));
    PyTuple_SetItem(args,1,PyoaPoleResidueModTypeEnum_FromoaPoleResidueModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPoleResidue::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaPoleResidue_doc[] = 
"Class: oaObserver_oaPoleResidue\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaPoleResidue(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaPoleResidue||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPoleResidue\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaPoleResidue(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaPoleResidue||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPoleResidue\n"
"  Paramegers: (oaObserver_oaPoleResidue)\n"
"    Calls: (const oaObserver_oaPoleResidue&)\n"
"    Signature: oaObserver_oaPoleResidue||cref-oaObserver_oaPoleResidue,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaPoleResidue_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaPoleResidue",
    sizeof(PyoaObserver_oaPoleResidueObject),
    0,
    (destructor)oaObserver_oaPoleResidue_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaPoleResidue_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaPoleResidue_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaPoleResidue_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaPoleResidue_oaPoleResidueModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaPoleResidue_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaPoleResidue_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaPoleResidue_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaPoleResidue\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaPoleResidue",
           (PyObject*)(&PyoaObserver_oaPoleResidue_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaPoleResidue\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaPolygon
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPolygon_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaPolygon_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaPolygonObject* self = (PyoaObserver_oaPolygonObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPolygon(p1.Data());
            }
            else {
                pyv_oaObserver_oaPolygon* p=new pyv_oaObserver_oaPolygon(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPolygon(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaPolygon* p=new pyv_oaObserver_oaPolygon(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaPolygon)
    {
        PyParamoaObserver_oaPolygon p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaPolygon_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaPolygon(p1.Data());
            }
            else {
                pyv_oaObserver_oaPolygon* p=new pyv_oaObserver_oaPolygon(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaPolygon, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaPolygon)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaPolygon_tp_dealloc(PyoaObserver_oaPolygonObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaPolygon*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPolygon_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaPolygon value;
    int convert_status=PyoaObserver_oaPolygon_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaObserver_oaPolygon::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaPolygon_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaPolygon v1;
    PyParamoaObserver_oaPolygon v2;
    int convert_status1=PyoaObserver_oaPolygon_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaPolygon_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaPolygon_Convert(PyObject* ob,PyParamoaObserver_oaPolygon* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaPolygon_Check(ob)) {
        result->SetData( (oaObserver_oaPolygon*) ((PyoaObserver_oaPolygonObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaPolygon Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaPolygon_FromoaObserver_oaPolygon(oaObserver_oaPolygon* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaPolygon_Type.tp_alloc(&PyoaObserver_oaPolygon_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaPolygonObject* self = (PyoaObserver_oaPolygonObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaPolygon::pyv_oaObserver_oaPolygon(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaPolygon(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPolygon::pyv_oaObserver_oaPolygon(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaPolygon(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPolygon::pyv_oaObserver_oaPolygon(const oaObserver_oaPolygon& p)
 : pyob(NULL),
   oaObserver_oaPolygon(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPolygon::onPostCreate(oaPolygon* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPolygon::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPolygon_FromoaPolygon(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPolygon::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPolygon::onPostModify(oaPolygon* p1,oaShapeModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPolygon::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPolygon_FromoaPolygon(p1));
    PyTuple_SetItem(args,1,PyoaShapeModTypeEnum_FromoaShapeModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPolygon::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPolygon::onPreDestroy(oaPolygon* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPolygon::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPolygon_FromoaPolygon(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPolygon::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPolygon::onPreModify(oaPolygon* p1,oaShapeModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPolygon::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPolygon_FromoaPolygon(p1));
    PyTuple_SetItem(args,1,PyoaShapeModTypeEnum_FromoaShapeModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPolygon::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaPolygon_doc[] = 
"Class: oaObserver_oaPolygon\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaPolygon(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaPolygon||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPolygon\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaPolygon(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaPolygon||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPolygon\n"
"  Paramegers: (oaObserver_oaPolygon)\n"
"    Calls: (const oaObserver_oaPolygon&)\n"
"    Signature: oaObserver_oaPolygon||cref-oaObserver_oaPolygon,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaPolygon_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaPolygon",
    sizeof(PyoaObserver_oaPolygonObject),
    0,
    (destructor)oaObserver_oaPolygon_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaPolygon_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaPolygon_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaPolygon_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaPolygon_oaShapeModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaPolygon_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaPolygon_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaPolygon_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaPolygon\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaPolygon",
           (PyObject*)(&PyoaObserver_oaPolygon_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaPolygon\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaProp
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaProp_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaProp_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaPropObject* self = (PyoaObserver_oaPropObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaProp(p1.Data());
            }
            else {
                pyv_oaObserver_oaProp* p=new pyv_oaObserver_oaProp(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaProp(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaProp* p=new pyv_oaObserver_oaProp(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaProp)
    {
        PyParamoaObserver_oaProp p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaProp_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaProp(p1.Data());
            }
            else {
                pyv_oaObserver_oaProp* p=new pyv_oaObserver_oaProp(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaProp, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaProp)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaProp_tp_dealloc(PyoaObserver_oaPropObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaProp*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaProp_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaProp value;
    int convert_status=PyoaObserver_oaProp_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[39];
    sprintf(buffer,"<oaObserver_oaProp::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaProp_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaProp v1;
    PyParamoaObserver_oaProp v2;
    int convert_status1=PyoaObserver_oaProp_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaProp_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaProp_Convert(PyObject* ob,PyParamoaObserver_oaProp* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaProp_Check(ob)) {
        result->SetData( (oaObserver_oaProp*) ((PyoaObserver_oaPropObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaProp Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaProp_FromoaObserver_oaProp(oaObserver_oaProp* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaProp_Type.tp_alloc(&PyoaObserver_oaProp_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaPropObject* self = (PyoaObserver_oaPropObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaProp::pyv_oaObserver_oaProp(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaProp(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaProp::pyv_oaObserver_oaProp(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaProp(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaProp::pyv_oaObserver_oaProp(const oaObserver_oaProp& p)
 : pyob(NULL),
   oaObserver_oaProp(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaProp::onPostCreate(oaProp* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaProp::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaProp_FromoaProp(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaProp::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaProp::onPostModify(oaProp* p1,oaPropModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaProp::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaProp_FromoaProp(p1));
    PyTuple_SetItem(args,1,PyoaPropModTypeEnum_FromoaPropModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaProp::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaProp::onPreDestroy(oaProp* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaProp::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaProp_FromoaProp(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaProp::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaProp::onPreModify(oaProp* p1,oaPropModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaProp::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaProp_FromoaProp(p1));
    PyTuple_SetItem(args,1,PyoaPropModTypeEnum_FromoaPropModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaProp::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaProp_doc[] = 
"Class: oaObserver_oaProp\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaProp(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaProp||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaProp\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaProp(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaProp||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaProp\n"
"  Paramegers: (oaObserver_oaProp)\n"
"    Calls: (const oaObserver_oaProp&)\n"
"    Signature: oaObserver_oaProp||cref-oaObserver_oaProp,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaProp_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaProp",
    sizeof(PyoaObserver_oaPropObject),
    0,
    (destructor)oaObserver_oaProp_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaProp_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaProp_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaProp_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaProp_oaPropModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaProp_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaProp_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaProp_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaProp\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaProp",
           (PyObject*)(&PyoaObserver_oaProp_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaProp\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaPropDisplay
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPropDisplay_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaPropDisplay_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaPropDisplayObject* self = (PyoaObserver_oaPropDisplayObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPropDisplay(p1.Data());
            }
            else {
                pyv_oaObserver_oaPropDisplay* p=new pyv_oaObserver_oaPropDisplay(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPropDisplay(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaPropDisplay* p=new pyv_oaObserver_oaPropDisplay(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaPropDisplay)
    {
        PyParamoaObserver_oaPropDisplay p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaPropDisplay_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaPropDisplay(p1.Data());
            }
            else {
                pyv_oaObserver_oaPropDisplay* p=new pyv_oaObserver_oaPropDisplay(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaPropDisplay, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaPropDisplay)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaPropDisplay_tp_dealloc(PyoaObserver_oaPropDisplayObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaPropDisplay*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPropDisplay_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaPropDisplay value;
    int convert_status=PyoaObserver_oaPropDisplay_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[46];
    sprintf(buffer,"<oaObserver_oaPropDisplay::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaPropDisplay_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaPropDisplay v1;
    PyParamoaObserver_oaPropDisplay v2;
    int convert_status1=PyoaObserver_oaPropDisplay_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaPropDisplay_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaPropDisplay_Convert(PyObject* ob,PyParamoaObserver_oaPropDisplay* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaPropDisplay_Check(ob)) {
        result->SetData( (oaObserver_oaPropDisplay*) ((PyoaObserver_oaPropDisplayObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaPropDisplay Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaPropDisplay_FromoaObserver_oaPropDisplay(oaObserver_oaPropDisplay* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaPropDisplay_Type.tp_alloc(&PyoaObserver_oaPropDisplay_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaPropDisplayObject* self = (PyoaObserver_oaPropDisplayObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaPropDisplay::pyv_oaObserver_oaPropDisplay(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaPropDisplay(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPropDisplay::pyv_oaObserver_oaPropDisplay(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaPropDisplay(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPropDisplay::pyv_oaObserver_oaPropDisplay(const oaObserver_oaPropDisplay& p)
 : pyob(NULL),
   oaObserver_oaPropDisplay(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPropDisplay::onPostCreate(oaPropDisplay* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPropDisplay::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPropDisplay_FromoaPropDisplay(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPropDisplay::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPropDisplay::onPostModify(oaPropDisplay* p1,oaShapeModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPropDisplay::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPropDisplay_FromoaPropDisplay(p1));
    PyTuple_SetItem(args,1,PyoaShapeModTypeEnum_FromoaShapeModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPropDisplay::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPropDisplay::onPreDestroy(oaPropDisplay* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPropDisplay::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPropDisplay_FromoaPropDisplay(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPropDisplay::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPropDisplay::onPreModify(oaPropDisplay* p1,oaShapeModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPropDisplay::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPropDisplay_FromoaPropDisplay(p1));
    PyTuple_SetItem(args,1,PyoaShapeModTypeEnum_FromoaShapeModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPropDisplay::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaPropDisplay_doc[] = 
"Class: oaObserver_oaPropDisplay\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaPropDisplay(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaPropDisplay||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPropDisplay\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaPropDisplay(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaPropDisplay||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPropDisplay\n"
"  Paramegers: (oaObserver_oaPropDisplay)\n"
"    Calls: (const oaObserver_oaPropDisplay&)\n"
"    Signature: oaObserver_oaPropDisplay||cref-oaObserver_oaPropDisplay,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaPropDisplay_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaPropDisplay",
    sizeof(PyoaObserver_oaPropDisplayObject),
    0,
    (destructor)oaObserver_oaPropDisplay_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaPropDisplay_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaPropDisplay_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaPropDisplay_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaPropDisplay_oaShapeModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaPropDisplay_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaPropDisplay_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaPropDisplay_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaPropDisplay\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaPropDisplay",
           (PyObject*)(&PyoaObserver_oaPropDisplay_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaPropDisplay\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaPurpose
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPurpose_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaPurpose_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaPurposeObject* self = (PyoaObserver_oaPurposeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPurpose(p1.Data());
            }
            else {
                pyv_oaObserver_oaPurpose* p=new pyv_oaObserver_oaPurpose(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaPurpose(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaPurpose* p=new pyv_oaObserver_oaPurpose(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaPurpose)
    {
        PyParamoaObserver_oaPurpose p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaPurpose_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaPurpose(p1.Data());
            }
            else {
                pyv_oaObserver_oaPurpose* p=new pyv_oaObserver_oaPurpose(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaPurpose, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaPurpose)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaPurpose_tp_dealloc(PyoaObserver_oaPurposeObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaPurpose*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaPurpose_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaPurpose value;
    int convert_status=PyoaObserver_oaPurpose_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaObserver_oaPurpose::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaPurpose_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaPurpose v1;
    PyParamoaObserver_oaPurpose v2;
    int convert_status1=PyoaObserver_oaPurpose_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaPurpose_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaPurpose_Convert(PyObject* ob,PyParamoaObserver_oaPurpose* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaPurpose_Check(ob)) {
        result->SetData( (oaObserver_oaPurpose*) ((PyoaObserver_oaPurposeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaPurpose Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaPurpose_FromoaObserver_oaPurpose(oaObserver_oaPurpose* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaPurpose_Type.tp_alloc(&PyoaObserver_oaPurpose_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaPurposeObject* self = (PyoaObserver_oaPurposeObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaPurpose::pyv_oaObserver_oaPurpose(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaPurpose(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPurpose::pyv_oaObserver_oaPurpose(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaPurpose(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaPurpose::pyv_oaObserver_oaPurpose(const oaObserver_oaPurpose& p)
 : pyob(NULL),
   oaObserver_oaPurpose(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPurpose::onPostCreate(oaPurpose* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPurpose::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPurpose_FromoaPurpose(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPurpose::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPurpose::onPostModify(oaPurpose* p1,oaPurposeModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPurpose::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPurpose_FromoaPurpose(p1));
    PyTuple_SetItem(args,1,PyoaPurposeModTypeEnum_FromoaPurposeModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPurpose::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPurpose::onPreDestroy(oaPurpose* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPurpose::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaPurpose_FromoaPurpose(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPurpose::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaPurpose::onPreModify(oaPurpose* p1,oaPurposeModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaPurpose::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaPurpose_FromoaPurpose(p1));
    PyTuple_SetItem(args,1,PyoaPurposeModTypeEnum_FromoaPurposeModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaPurpose::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaPurpose_doc[] = 
"Class: oaObserver_oaPurpose\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaPurpose(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaPurpose||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPurpose\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaPurpose(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaPurpose||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaPurpose\n"
"  Paramegers: (oaObserver_oaPurpose)\n"
"    Calls: (const oaObserver_oaPurpose&)\n"
"    Signature: oaObserver_oaPurpose||cref-oaObserver_oaPurpose,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaPurpose_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaPurpose",
    sizeof(PyoaObserver_oaPurposeObject),
    0,
    (destructor)oaObserver_oaPurpose_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaPurpose_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaPurpose_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaPurpose_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaPurpose_oaPurposeModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaPurpose_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaPurpose_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaPurpose_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaPurpose\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaPurpose",
           (PyObject*)(&PyoaObserver_oaPurpose_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaPurpose\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaRect
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaRect_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaRect_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaRectObject* self = (PyoaObserver_oaRectObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaRect(p1.Data());
            }
            else {
                pyv_oaObserver_oaRect* p=new pyv_oaObserver_oaRect(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaRect(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaRect* p=new pyv_oaObserver_oaRect(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaRect)
    {
        PyParamoaObserver_oaRect p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaRect_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaRect(p1.Data());
            }
            else {
                pyv_oaObserver_oaRect* p=new pyv_oaObserver_oaRect(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaRect, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaRect)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaRect_tp_dealloc(PyoaObserver_oaRectObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaRect*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaRect_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaRect value;
    int convert_status=PyoaObserver_oaRect_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[39];
    sprintf(buffer,"<oaObserver_oaRect::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaRect_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaRect v1;
    PyParamoaObserver_oaRect v2;
    int convert_status1=PyoaObserver_oaRect_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaRect_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaRect_Convert(PyObject* ob,PyParamoaObserver_oaRect* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaRect_Check(ob)) {
        result->SetData( (oaObserver_oaRect*) ((PyoaObserver_oaRectObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaRect Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaRect_FromoaObserver_oaRect(oaObserver_oaRect* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaRect_Type.tp_alloc(&PyoaObserver_oaRect_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaRectObject* self = (PyoaObserver_oaRectObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaRect::pyv_oaObserver_oaRect(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaRect(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaRect::pyv_oaObserver_oaRect(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaRect(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaRect::pyv_oaObserver_oaRect(const oaObserver_oaRect& p)
 : pyob(NULL),
   oaObserver_oaRect(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaRect::onPostCreate(oaRect* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaRect::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaRect_FromoaRect(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaRect::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaRect::onPostModify(oaRect* p1,oaShapeModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaRect::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaRect_FromoaRect(p1));
    PyTuple_SetItem(args,1,PyoaShapeModTypeEnum_FromoaShapeModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaRect::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaRect::onPreDestroy(oaRect* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaRect::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaRect_FromoaRect(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaRect::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaRect::onPreModify(oaRect* p1,oaShapeModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaRect::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaRect_FromoaRect(p1));
    PyTuple_SetItem(args,1,PyoaShapeModTypeEnum_FromoaShapeModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaRect::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaRect_doc[] = 
"Class: oaObserver_oaRect\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaRect(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaRect||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaRect\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaRect(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaRect||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaRect\n"
"  Paramegers: (oaObserver_oaRect)\n"
"    Calls: (const oaObserver_oaRect&)\n"
"    Signature: oaObserver_oaRect||cref-oaObserver_oaRect,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaRect_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaRect",
    sizeof(PyoaObserver_oaRectObject),
    0,
    (destructor)oaObserver_oaRect_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaRect_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaRect_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaRect_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaRect_oaShapeModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaRect_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaRect_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaRect_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaRect\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaRect",
           (PyObject*)(&PyoaObserver_oaRect_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaRect\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaReducedModel
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaReducedModel_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaReducedModel_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaReducedModelObject* self = (PyoaObserver_oaReducedModelObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaReducedModel(p1.Data());
            }
            else {
                pyv_oaObserver_oaReducedModel* p=new pyv_oaObserver_oaReducedModel(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaReducedModel(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaReducedModel* p=new pyv_oaObserver_oaReducedModel(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaReducedModel)
    {
        PyParamoaObserver_oaReducedModel p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaReducedModel_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaReducedModel(p1.Data());
            }
            else {
                pyv_oaObserver_oaReducedModel* p=new pyv_oaObserver_oaReducedModel(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaReducedModel, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaReducedModel)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaReducedModel_tp_dealloc(PyoaObserver_oaReducedModelObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaReducedModel*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaReducedModel_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaReducedModel value;
    int convert_status=PyoaObserver_oaReducedModel_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[47];
    sprintf(buffer,"<oaObserver_oaReducedModel::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaReducedModel_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaReducedModel v1;
    PyParamoaObserver_oaReducedModel v2;
    int convert_status1=PyoaObserver_oaReducedModel_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaReducedModel_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaReducedModel_Convert(PyObject* ob,PyParamoaObserver_oaReducedModel* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaReducedModel_Check(ob)) {
        result->SetData( (oaObserver_oaReducedModel*) ((PyoaObserver_oaReducedModelObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaReducedModel Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaReducedModel_FromoaObserver_oaReducedModel(oaObserver_oaReducedModel* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaReducedModel_Type.tp_alloc(&PyoaObserver_oaReducedModel_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaReducedModelObject* self = (PyoaObserver_oaReducedModelObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaReducedModel::pyv_oaObserver_oaReducedModel(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaReducedModel(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaReducedModel::pyv_oaObserver_oaReducedModel(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaReducedModel(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaReducedModel::pyv_oaObserver_oaReducedModel(const oaObserver_oaReducedModel& p)
 : pyob(NULL),
   oaObserver_oaReducedModel(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaReducedModel::onPostCreate(oaReducedModel* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaReducedModel::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaReducedModel_FromoaReducedModel(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaReducedModel::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaReducedModel::onPostModify(oaReducedModel* p1,oaReducedModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaReducedModel::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaReducedModel_FromoaReducedModel(p1));
    PyTuple_SetItem(args,1,PyoaReducedModTypeEnum_FromoaReducedModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaReducedModel::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaReducedModel::onPreDestroy(oaReducedModel* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaReducedModel::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaReducedModel_FromoaReducedModel(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaReducedModel::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaReducedModel::onPreModify(oaReducedModel* p1,oaReducedModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaReducedModel::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaReducedModel_FromoaReducedModel(p1));
    PyTuple_SetItem(args,1,PyoaReducedModTypeEnum_FromoaReducedModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaReducedModel::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaReducedModel_doc[] = 
"Class: oaObserver_oaReducedModel\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaReducedModel(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaReducedModel||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaReducedModel\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaReducedModel(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaReducedModel||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaReducedModel\n"
"  Paramegers: (oaObserver_oaReducedModel)\n"
"    Calls: (const oaObserver_oaReducedModel&)\n"
"    Signature: oaObserver_oaReducedModel||cref-oaObserver_oaReducedModel,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaReducedModel_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaReducedModel",
    sizeof(PyoaObserver_oaReducedModelObject),
    0,
    (destructor)oaObserver_oaReducedModel_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaReducedModel_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaReducedModel_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaReducedModel_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaReducedModel_oaReducedModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaReducedModel_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaReducedModel_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaReducedModel_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaReducedModel\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaReducedModel",
           (PyObject*)(&PyoaObserver_oaReducedModel_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaReducedModel\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaResistor
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaResistor_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaResistor_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaResistorObject* self = (PyoaObserver_oaResistorObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaResistor(p1.Data());
            }
            else {
                pyv_oaObserver_oaResistor* p=new pyv_oaObserver_oaResistor(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaResistor(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaResistor* p=new pyv_oaObserver_oaResistor(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaResistor)
    {
        PyParamoaObserver_oaResistor p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaResistor_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaResistor(p1.Data());
            }
            else {
                pyv_oaObserver_oaResistor* p=new pyv_oaObserver_oaResistor(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaResistor, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaResistor)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaResistor_tp_dealloc(PyoaObserver_oaResistorObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaResistor*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaResistor_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaResistor value;
    int convert_status=PyoaObserver_oaResistor_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaObserver_oaResistor::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaResistor_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaResistor v1;
    PyParamoaObserver_oaResistor v2;
    int convert_status1=PyoaObserver_oaResistor_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaResistor_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaResistor_Convert(PyObject* ob,PyParamoaObserver_oaResistor* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaResistor_Check(ob)) {
        result->SetData( (oaObserver_oaResistor*) ((PyoaObserver_oaResistorObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaResistor Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaResistor_FromoaObserver_oaResistor(oaObserver_oaResistor* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaResistor_Type.tp_alloc(&PyoaObserver_oaResistor_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaResistorObject* self = (PyoaObserver_oaResistorObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaResistor::pyv_oaObserver_oaResistor(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaResistor(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaResistor::pyv_oaObserver_oaResistor(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaResistor(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaResistor::pyv_oaObserver_oaResistor(const oaObserver_oaResistor& p)
 : pyob(NULL),
   oaObserver_oaResistor(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaResistor::onPostCreate(oaResistor* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaResistor::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaResistor_FromoaResistor(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaResistor::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaResistor::onPostModify(oaResistor* p1,oaDeviceModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaResistor::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaResistor_FromoaResistor(p1));
    PyTuple_SetItem(args,1,PyoaDeviceModTypeEnum_FromoaDeviceModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaResistor::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaResistor::onPreDestroy(oaResistor* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaResistor::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaResistor_FromoaResistor(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaResistor::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaResistor::onPreModify(oaResistor* p1,oaDeviceModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaResistor::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaResistor_FromoaResistor(p1));
    PyTuple_SetItem(args,1,PyoaDeviceModTypeEnum_FromoaDeviceModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaResistor::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaResistor_doc[] = 
"Class: oaObserver_oaResistor\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaResistor(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaResistor||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaResistor\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaResistor(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaResistor||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaResistor\n"
"  Paramegers: (oaObserver_oaResistor)\n"
"    Calls: (const oaObserver_oaResistor&)\n"
"    Signature: oaObserver_oaResistor||cref-oaObserver_oaResistor,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaResistor_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaResistor",
    sizeof(PyoaObserver_oaResistorObject),
    0,
    (destructor)oaObserver_oaResistor_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaResistor_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaResistor_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaResistor_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaResistor_oaDeviceModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaResistor_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaResistor_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaResistor_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaResistor\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaResistor",
           (PyObject*)(&PyoaObserver_oaResistor_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaResistor\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaReticle
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaReticle_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaReticle_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaReticleObject* self = (PyoaObserver_oaReticleObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaReticle(p1.Data());
            }
            else {
                pyv_oaObserver_oaReticle* p=new pyv_oaObserver_oaReticle(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaReticle(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaReticle* p=new pyv_oaObserver_oaReticle(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaReticle)
    {
        PyParamoaObserver_oaReticle p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaReticle_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaReticle(p1.Data());
            }
            else {
                pyv_oaObserver_oaReticle* p=new pyv_oaObserver_oaReticle(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaReticle, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaReticle)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaReticle_tp_dealloc(PyoaObserver_oaReticleObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaReticle*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaReticle_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaReticle value;
    int convert_status=PyoaObserver_oaReticle_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaObserver_oaReticle::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaReticle_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaReticle v1;
    PyParamoaObserver_oaReticle v2;
    int convert_status1=PyoaObserver_oaReticle_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaReticle_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaReticle_Convert(PyObject* ob,PyParamoaObserver_oaReticle* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaReticle_Check(ob)) {
        result->SetData( (oaObserver_oaReticle*) ((PyoaObserver_oaReticleObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaReticle Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaReticle_FromoaObserver_oaReticle(oaObserver_oaReticle* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaReticle_Type.tp_alloc(&PyoaObserver_oaReticle_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaReticleObject* self = (PyoaObserver_oaReticleObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaReticle::pyv_oaObserver_oaReticle(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaReticle(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaReticle::pyv_oaObserver_oaReticle(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaReticle(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaReticle::pyv_oaObserver_oaReticle(const oaObserver_oaReticle& p)
 : pyob(NULL),
   oaObserver_oaReticle(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaReticle::onPostCreate(oaReticle* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaReticle::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaReticle_FromoaReticle(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaReticle::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaReticle::onPostModify(oaReticle* p1,oaReticleModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaReticle::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaReticle_FromoaReticle(p1));
    PyTuple_SetItem(args,1,PyoaReticleModTypeEnum_FromoaReticleModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaReticle::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaReticle::onPreDestroy(oaReticle* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaReticle::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaReticle_FromoaReticle(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaReticle::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaReticle::onPreModify(oaReticle* p1,oaReticleModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaReticle::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaReticle_FromoaReticle(p1));
    PyTuple_SetItem(args,1,PyoaReticleModTypeEnum_FromoaReticleModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaReticle::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaReticle_doc[] = 
"Class: oaObserver_oaReticle\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaReticle(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaReticle||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaReticle\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaReticle(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaReticle||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaReticle\n"
"  Paramegers: (oaObserver_oaReticle)\n"
"    Calls: (const oaObserver_oaReticle&)\n"
"    Signature: oaObserver_oaReticle||cref-oaObserver_oaReticle,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaReticle_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaReticle",
    sizeof(PyoaObserver_oaReticleObject),
    0,
    (destructor)oaObserver_oaReticle_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaReticle_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaReticle_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaReticle_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaReticle_oaReticleModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaReticle_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaReticle_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaReticle_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaReticle\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaReticle",
           (PyObject*)(&PyoaObserver_oaReticle_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaReticle\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaReticleRef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaReticleRef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaReticleRef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaReticleRefObject* self = (PyoaObserver_oaReticleRefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaReticleRef(p1.Data());
            }
            else {
                pyv_oaObserver_oaReticleRef* p=new pyv_oaObserver_oaReticleRef(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaReticleRef(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaReticleRef* p=new pyv_oaObserver_oaReticleRef(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaReticleRef)
    {
        PyParamoaObserver_oaReticleRef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaReticleRef_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaReticleRef(p1.Data());
            }
            else {
                pyv_oaObserver_oaReticleRef* p=new pyv_oaObserver_oaReticleRef(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaReticleRef, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaReticleRef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaReticleRef_tp_dealloc(PyoaObserver_oaReticleRefObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaReticleRef*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaReticleRef_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaReticleRef value;
    int convert_status=PyoaObserver_oaReticleRef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaObserver_oaReticleRef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaReticleRef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaReticleRef v1;
    PyParamoaObserver_oaReticleRef v2;
    int convert_status1=PyoaObserver_oaReticleRef_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaReticleRef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaReticleRef_Convert(PyObject* ob,PyParamoaObserver_oaReticleRef* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaReticleRef_Check(ob)) {
        result->SetData( (oaObserver_oaReticleRef*) ((PyoaObserver_oaReticleRefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaReticleRef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaReticleRef_FromoaObserver_oaReticleRef(oaObserver_oaReticleRef* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaReticleRef_Type.tp_alloc(&PyoaObserver_oaReticleRef_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaReticleRefObject* self = (PyoaObserver_oaReticleRefObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaReticleRef::pyv_oaObserver_oaReticleRef(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaReticleRef(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaReticleRef::pyv_oaObserver_oaReticleRef(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaReticleRef(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaReticleRef::pyv_oaObserver_oaReticleRef(const oaObserver_oaReticleRef& p)
 : pyob(NULL),
   oaObserver_oaReticleRef(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaReticleRef::onPostCreate(oaReticleRef* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaReticleRef::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaReticleRef_FromoaReticleRef(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaReticleRef::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaReticleRef::onPostModify(oaReticleRef* p1,oaReticleRefModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaReticleRef::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaReticleRef_FromoaReticleRef(p1));
    PyTuple_SetItem(args,1,PyoaReticleRefModTypeEnum_FromoaReticleRefModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaReticleRef::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaReticleRef::onPreDestroy(oaReticleRef* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaReticleRef::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaReticleRef_FromoaReticleRef(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaReticleRef::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaReticleRef::onPreModify(oaReticleRef* p1,oaReticleRefModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaReticleRef::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaReticleRef_FromoaReticleRef(p1));
    PyTuple_SetItem(args,1,PyoaReticleRefModTypeEnum_FromoaReticleRefModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaReticleRef::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaReticleRef_doc[] = 
"Class: oaObserver_oaReticleRef\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaReticleRef(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaReticleRef||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaReticleRef\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaReticleRef(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaReticleRef||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaReticleRef\n"
"  Paramegers: (oaObserver_oaReticleRef)\n"
"    Calls: (const oaObserver_oaReticleRef&)\n"
"    Signature: oaObserver_oaReticleRef||cref-oaObserver_oaReticleRef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaReticleRef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaReticleRef",
    sizeof(PyoaObserver_oaReticleRefObject),
    0,
    (destructor)oaObserver_oaReticleRef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaReticleRef_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaReticleRef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaReticleRef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaReticleRef_oaReticleRefModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaReticleRef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaReticleRef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaReticleRef_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaReticleRef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaReticleRef",
           (PyObject*)(&PyoaObserver_oaReticleRef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaReticleRef\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaRoute
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaRoute_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaRoute_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaRouteObject* self = (PyoaObserver_oaRouteObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaRoute(p1.Data());
            }
            else {
                pyv_oaObserver_oaRoute* p=new pyv_oaObserver_oaRoute(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaRoute(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaRoute* p=new pyv_oaObserver_oaRoute(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaRoute)
    {
        PyParamoaObserver_oaRoute p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaRoute_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaRoute(p1.Data());
            }
            else {
                pyv_oaObserver_oaRoute* p=new pyv_oaObserver_oaRoute(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaRoute, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaRoute)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaRoute_tp_dealloc(PyoaObserver_oaRouteObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaRoute*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaRoute_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaRoute value;
    int convert_status=PyoaObserver_oaRoute_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[40];
    sprintf(buffer,"<oaObserver_oaRoute::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaRoute_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaRoute v1;
    PyParamoaObserver_oaRoute v2;
    int convert_status1=PyoaObserver_oaRoute_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaRoute_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaRoute_Convert(PyObject* ob,PyParamoaObserver_oaRoute* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaRoute_Check(ob)) {
        result->SetData( (oaObserver_oaRoute*) ((PyoaObserver_oaRouteObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaRoute Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaRoute_FromoaObserver_oaRoute(oaObserver_oaRoute* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaRoute_Type.tp_alloc(&PyoaObserver_oaRoute_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaRouteObject* self = (PyoaObserver_oaRouteObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaRoute::pyv_oaObserver_oaRoute(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaRoute(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaRoute::pyv_oaObserver_oaRoute(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaRoute(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaRoute::pyv_oaObserver_oaRoute(const oaObserver_oaRoute& p)
 : pyob(NULL),
   oaObserver_oaRoute(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaRoute::onPostCreate(oaRoute* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaRoute::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaRoute_FromoaRoute(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaRoute::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaRoute::onPostModify(oaRoute* p1,oaRouteModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaRoute::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaRoute_FromoaRoute(p1));
    PyTuple_SetItem(args,1,PyoaRouteModTypeEnum_FromoaRouteModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaRoute::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaRoute::onPreDestroy(oaRoute* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaRoute::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaRoute_FromoaRoute(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaRoute::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaRoute::onPreModify(oaRoute* p1,oaRouteModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaRoute::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaRoute_FromoaRoute(p1));
    PyTuple_SetItem(args,1,PyoaRouteModTypeEnum_FromoaRouteModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaRoute::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaRoute_doc[] = 
"Class: oaObserver_oaRoute\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaRoute(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaRoute||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaRoute\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaRoute(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaRoute||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaRoute\n"
"  Paramegers: (oaObserver_oaRoute)\n"
"    Calls: (const oaObserver_oaRoute&)\n"
"    Signature: oaObserver_oaRoute||cref-oaObserver_oaRoute,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaRoute_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaRoute",
    sizeof(PyoaObserver_oaRouteObject),
    0,
    (destructor)oaObserver_oaRoute_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaRoute_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaRoute_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaRoute_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaRoute_oaRouteModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaRoute_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaRoute_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaRoute_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaRoute\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaRoute",
           (PyObject*)(&PyoaObserver_oaRoute_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaRoute\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaRow
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaRow_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaRow_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaRowObject* self = (PyoaObserver_oaRowObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaRow(p1.Data());
            }
            else {
                pyv_oaObserver_oaRow* p=new pyv_oaObserver_oaRow(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaRow(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaRow* p=new pyv_oaObserver_oaRow(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaRow)
    {
        PyParamoaObserver_oaRow p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaRow_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaRow(p1.Data());
            }
            else {
                pyv_oaObserver_oaRow* p=new pyv_oaObserver_oaRow(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaRow, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaRow)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaRow_tp_dealloc(PyoaObserver_oaRowObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaRow*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaRow_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaRow value;
    int convert_status=PyoaObserver_oaRow_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[38];
    sprintf(buffer,"<oaObserver_oaRow::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaRow_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaRow v1;
    PyParamoaObserver_oaRow v2;
    int convert_status1=PyoaObserver_oaRow_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaRow_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaRow_Convert(PyObject* ob,PyParamoaObserver_oaRow* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaRow_Check(ob)) {
        result->SetData( (oaObserver_oaRow*) ((PyoaObserver_oaRowObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaRow Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaRow_FromoaObserver_oaRow(oaObserver_oaRow* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaRow_Type.tp_alloc(&PyoaObserver_oaRow_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaRowObject* self = (PyoaObserver_oaRowObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaRow::pyv_oaObserver_oaRow(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaRow(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaRow::pyv_oaObserver_oaRow(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaRow(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaRow::pyv_oaObserver_oaRow(const oaObserver_oaRow& p)
 : pyob(NULL),
   oaObserver_oaRow(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaRow::onPostCreate(oaRow* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaRow::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaRow_FromoaRow(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaRow::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaRow::onPostModify(oaRow* p1,oaRowModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaRow::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaRow_FromoaRow(p1));
    PyTuple_SetItem(args,1,PyoaRowModTypeEnum_FromoaRowModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaRow::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaRow::onPreDestroy(oaRow* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaRow::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaRow_FromoaRow(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaRow::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaRow::onPreModify(oaRow* p1,oaRowModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaRow::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaRow_FromoaRow(p1));
    PyTuple_SetItem(args,1,PyoaRowModTypeEnum_FromoaRowModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaRow::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaRow_doc[] = 
"Class: oaObserver_oaRow\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaRow(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaRow||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaRow\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaRow(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaRow||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaRow\n"
"  Paramegers: (oaObserver_oaRow)\n"
"    Calls: (const oaObserver_oaRow&)\n"
"    Signature: oaObserver_oaRow||cref-oaObserver_oaRow,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaRow_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaRow",
    sizeof(PyoaObserver_oaRowObject),
    0,
    (destructor)oaObserver_oaRow_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaRow_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaRow_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaRow_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaRow_oaRowModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaRow_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaRow_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaRow_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaRow\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaRow",
           (PyObject*)(&PyoaObserver_oaRow_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaRow\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaRowHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaRowHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaRowHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaRowHeaderObject* self = (PyoaObserver_oaRowHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaRowHeader(p1.Data());
            }
            else {
                pyv_oaObserver_oaRowHeader* p=new pyv_oaObserver_oaRowHeader(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaRowHeader(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaRowHeader* p=new pyv_oaObserver_oaRowHeader(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaRowHeader)
    {
        PyParamoaObserver_oaRowHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaRowHeader_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaRowHeader(p1.Data());
            }
            else {
                pyv_oaObserver_oaRowHeader* p=new pyv_oaObserver_oaRowHeader(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaRowHeader, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaRowHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaRowHeader_tp_dealloc(PyoaObserver_oaRowHeaderObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaRowHeader*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaRowHeader_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaRowHeader value;
    int convert_status=PyoaObserver_oaRowHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaObserver_oaRowHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaRowHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaRowHeader v1;
    PyParamoaObserver_oaRowHeader v2;
    int convert_status1=PyoaObserver_oaRowHeader_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaRowHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaRowHeader_Convert(PyObject* ob,PyParamoaObserver_oaRowHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaRowHeader_Check(ob)) {
        result->SetData( (oaObserver_oaRowHeader*) ((PyoaObserver_oaRowHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaRowHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaRowHeader_FromoaObserver_oaRowHeader(oaObserver_oaRowHeader* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaRowHeader_Type.tp_alloc(&PyoaObserver_oaRowHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaRowHeaderObject* self = (PyoaObserver_oaRowHeaderObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaRowHeader::pyv_oaObserver_oaRowHeader(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaRowHeader(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaRowHeader::pyv_oaObserver_oaRowHeader(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaRowHeader(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaRowHeader::pyv_oaObserver_oaRowHeader(const oaObserver_oaRowHeader& p)
 : pyob(NULL),
   oaObserver_oaRowHeader(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaRowHeader::onPostCreate(oaRowHeader* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaRowHeader::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaRowHeader_FromoaRowHeader(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaRowHeader::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaRowHeader::onPostModify(oaRowHeader* p1,oaRowHeaderModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaRowHeader::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaRowHeader_FromoaRowHeader(p1));
    PyTuple_SetItem(args,1,PyoaRowHeaderModTypeEnum_FromoaRowHeaderModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaRowHeader::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaRowHeader::onPreDestroy(oaRowHeader* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaRowHeader::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaRowHeader_FromoaRowHeader(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaRowHeader::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaRowHeader::onPreModify(oaRowHeader* p1,oaRowHeaderModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaRowHeader::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaRowHeader_FromoaRowHeader(p1));
    PyTuple_SetItem(args,1,PyoaRowHeaderModTypeEnum_FromoaRowHeaderModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaRowHeader::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaRowHeader_doc[] = 
"Class: oaObserver_oaRowHeader\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaRowHeader(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaRowHeader||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaRowHeader\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaRowHeader(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaRowHeader||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaRowHeader\n"
"  Paramegers: (oaObserver_oaRowHeader)\n"
"    Calls: (const oaObserver_oaRowHeader&)\n"
"    Signature: oaObserver_oaRowHeader||cref-oaObserver_oaRowHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaRowHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaRowHeader",
    sizeof(PyoaObserver_oaRowHeaderObject),
    0,
    (destructor)oaObserver_oaRowHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaRowHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaRowHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaRowHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaRowHeader_oaRowHeaderModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaRowHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaRowHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaRowHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaRowHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaRowHeader",
           (PyObject*)(&PyoaObserver_oaRowHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaRowHeader\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaScalarInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaScalarInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaScalarInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaScalarInstObject* self = (PyoaObserver_oaScalarInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaScalarInst(p1.Data());
            }
            else {
                pyv_oaObserver_oaScalarInst* p=new pyv_oaObserver_oaScalarInst(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaScalarInst(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaScalarInst* p=new pyv_oaObserver_oaScalarInst(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaScalarInst)
    {
        PyParamoaObserver_oaScalarInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaScalarInst_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaScalarInst(p1.Data());
            }
            else {
                pyv_oaObserver_oaScalarInst* p=new pyv_oaObserver_oaScalarInst(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaScalarInst, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaScalarInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaScalarInst_tp_dealloc(PyoaObserver_oaScalarInstObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaScalarInst*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaScalarInst_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaScalarInst value;
    int convert_status=PyoaObserver_oaScalarInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaObserver_oaScalarInst::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaScalarInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaScalarInst v1;
    PyParamoaObserver_oaScalarInst v2;
    int convert_status1=PyoaObserver_oaScalarInst_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaScalarInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaScalarInst_Convert(PyObject* ob,PyParamoaObserver_oaScalarInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaScalarInst_Check(ob)) {
        result->SetData( (oaObserver_oaScalarInst*) ((PyoaObserver_oaScalarInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaScalarInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaScalarInst_FromoaObserver_oaScalarInst(oaObserver_oaScalarInst* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaScalarInst_Type.tp_alloc(&PyoaObserver_oaScalarInst_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaScalarInstObject* self = (PyoaObserver_oaScalarInstObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaScalarInst::pyv_oaObserver_oaScalarInst(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaScalarInst(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaScalarInst::pyv_oaObserver_oaScalarInst(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaScalarInst(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaScalarInst::pyv_oaObserver_oaScalarInst(const oaObserver_oaScalarInst& p)
 : pyob(NULL),
   oaObserver_oaScalarInst(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScalarInst::onPostCreate(oaScalarInst* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarInst::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaScalarInst_FromoaScalarInst(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarInst::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScalarInst::onPostModify(oaScalarInst* p1,oaInstModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarInst::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaScalarInst_FromoaScalarInst(p1));
    PyTuple_SetItem(args,1,PyoaInstModTypeEnum_FromoaInstModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarInst::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScalarInst::onPreDestroy(oaScalarInst* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarInst::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaScalarInst_FromoaScalarInst(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarInst::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScalarInst::onPreModify(oaScalarInst* p1,oaInstModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarInst::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaScalarInst_FromoaScalarInst(p1));
    PyTuple_SetItem(args,1,PyoaInstModTypeEnum_FromoaInstModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarInst::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaScalarInst_doc[] = 
"Class: oaObserver_oaScalarInst\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaScalarInst(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaScalarInst||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaScalarInst\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaScalarInst(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaScalarInst||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaScalarInst\n"
"  Paramegers: (oaObserver_oaScalarInst)\n"
"    Calls: (const oaObserver_oaScalarInst&)\n"
"    Signature: oaObserver_oaScalarInst||cref-oaObserver_oaScalarInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaScalarInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaScalarInst",
    sizeof(PyoaObserver_oaScalarInstObject),
    0,
    (destructor)oaObserver_oaScalarInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaScalarInst_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaScalarInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaScalarInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaScalarInst_oaInstModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaScalarInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaScalarInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaScalarInst_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaScalarInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaScalarInst",
           (PyObject*)(&PyoaObserver_oaScalarInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaScalarInst\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaScalarNet
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaScalarNet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaScalarNet_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaScalarNetObject* self = (PyoaObserver_oaScalarNetObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaScalarNet(p1.Data());
            }
            else {
                pyv_oaObserver_oaScalarNet* p=new pyv_oaObserver_oaScalarNet(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaScalarNet(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaScalarNet* p=new pyv_oaObserver_oaScalarNet(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaScalarNet)
    {
        PyParamoaObserver_oaScalarNet p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaScalarNet_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaScalarNet(p1.Data());
            }
            else {
                pyv_oaObserver_oaScalarNet* p=new pyv_oaObserver_oaScalarNet(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaScalarNet, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaScalarNet)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaScalarNet_tp_dealloc(PyoaObserver_oaScalarNetObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaScalarNet*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaScalarNet_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaScalarNet value;
    int convert_status=PyoaObserver_oaScalarNet_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaObserver_oaScalarNet::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaScalarNet_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaScalarNet v1;
    PyParamoaObserver_oaScalarNet v2;
    int convert_status1=PyoaObserver_oaScalarNet_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaScalarNet_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaScalarNet_Convert(PyObject* ob,PyParamoaObserver_oaScalarNet* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaScalarNet_Check(ob)) {
        result->SetData( (oaObserver_oaScalarNet*) ((PyoaObserver_oaScalarNetObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaScalarNet Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaScalarNet_FromoaObserver_oaScalarNet(oaObserver_oaScalarNet* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaScalarNet_Type.tp_alloc(&PyoaObserver_oaScalarNet_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaScalarNetObject* self = (PyoaObserver_oaScalarNetObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaScalarNet::pyv_oaObserver_oaScalarNet(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaScalarNet(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaScalarNet::pyv_oaObserver_oaScalarNet(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaScalarNet(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaScalarNet::pyv_oaObserver_oaScalarNet(const oaObserver_oaScalarNet& p)
 : pyob(NULL),
   oaObserver_oaScalarNet(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScalarNet::onPostCreate(oaScalarNet* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarNet::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaScalarNet_FromoaScalarNet(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarNet::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScalarNet::onPostModify(oaScalarNet* p1,oaNetModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarNet::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaScalarNet_FromoaScalarNet(p1));
    PyTuple_SetItem(args,1,PyoaNetModTypeEnum_FromoaNetModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarNet::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScalarNet::onPreDestroy(oaScalarNet* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarNet::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaScalarNet_FromoaScalarNet(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarNet::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScalarNet::onPreModify(oaScalarNet* p1,oaNetModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarNet::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaScalarNet_FromoaScalarNet(p1));
    PyTuple_SetItem(args,1,PyoaNetModTypeEnum_FromoaNetModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarNet::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaScalarNet_doc[] = 
"Class: oaObserver_oaScalarNet\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaScalarNet(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaScalarNet||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaScalarNet\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaScalarNet(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaScalarNet||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaScalarNet\n"
"  Paramegers: (oaObserver_oaScalarNet)\n"
"    Calls: (const oaObserver_oaScalarNet&)\n"
"    Signature: oaObserver_oaScalarNet||cref-oaObserver_oaScalarNet,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaScalarNet_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaScalarNet",
    sizeof(PyoaObserver_oaScalarNetObject),
    0,
    (destructor)oaObserver_oaScalarNet_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaScalarNet_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaScalarNet_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaScalarNet_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaScalarNet_oaNetModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaScalarNet_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaScalarNet_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaScalarNet_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaScalarNet\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaScalarNet",
           (PyObject*)(&PyoaObserver_oaScalarNet_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaScalarNet\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaScalarSiteDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaScalarSiteDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaScalarSiteDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaScalarSiteDefObject* self = (PyoaObserver_oaScalarSiteDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaScalarSiteDef(p1.Data());
            }
            else {
                pyv_oaObserver_oaScalarSiteDef* p=new pyv_oaObserver_oaScalarSiteDef(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaScalarSiteDef(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaScalarSiteDef* p=new pyv_oaObserver_oaScalarSiteDef(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaScalarSiteDef)
    {
        PyParamoaObserver_oaScalarSiteDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaScalarSiteDef_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaScalarSiteDef(p1.Data());
            }
            else {
                pyv_oaObserver_oaScalarSiteDef* p=new pyv_oaObserver_oaScalarSiteDef(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaScalarSiteDef, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaScalarSiteDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaScalarSiteDef_tp_dealloc(PyoaObserver_oaScalarSiteDefObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaScalarSiteDef*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaScalarSiteDef_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaScalarSiteDef value;
    int convert_status=PyoaObserver_oaScalarSiteDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[48];
    sprintf(buffer,"<oaObserver_oaScalarSiteDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaScalarSiteDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaScalarSiteDef v1;
    PyParamoaObserver_oaScalarSiteDef v2;
    int convert_status1=PyoaObserver_oaScalarSiteDef_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaScalarSiteDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaScalarSiteDef_Convert(PyObject* ob,PyParamoaObserver_oaScalarSiteDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaScalarSiteDef_Check(ob)) {
        result->SetData( (oaObserver_oaScalarSiteDef*) ((PyoaObserver_oaScalarSiteDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaScalarSiteDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaScalarSiteDef_FromoaObserver_oaScalarSiteDef(oaObserver_oaScalarSiteDef* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaScalarSiteDef_Type.tp_alloc(&PyoaObserver_oaScalarSiteDef_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaScalarSiteDefObject* self = (PyoaObserver_oaScalarSiteDefObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaScalarSiteDef::pyv_oaObserver_oaScalarSiteDef(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaScalarSiteDef(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaScalarSiteDef::pyv_oaObserver_oaScalarSiteDef(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaScalarSiteDef(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaScalarSiteDef::pyv_oaObserver_oaScalarSiteDef(const oaObserver_oaScalarSiteDef& p)
 : pyob(NULL),
   oaObserver_oaScalarSiteDef(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScalarSiteDef::onPostCreate(oaScalarSiteDef* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarSiteDef::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaScalarSiteDef_FromoaScalarSiteDef(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarSiteDef::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScalarSiteDef::onPostModify(oaScalarSiteDef* p1,oaSiteDefModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarSiteDef::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaScalarSiteDef_FromoaScalarSiteDef(p1));
    PyTuple_SetItem(args,1,PyoaSiteDefModTypeEnum_FromoaSiteDefModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarSiteDef::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScalarSiteDef::onPreDestroy(oaScalarSiteDef* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarSiteDef::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaScalarSiteDef_FromoaScalarSiteDef(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarSiteDef::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScalarSiteDef::onPreModify(oaScalarSiteDef* p1,oaSiteDefModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarSiteDef::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaScalarSiteDef_FromoaScalarSiteDef(p1));
    PyTuple_SetItem(args,1,PyoaSiteDefModTypeEnum_FromoaSiteDefModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarSiteDef::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaScalarSiteDef_doc[] = 
"Class: oaObserver_oaScalarSiteDef\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaScalarSiteDef(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaScalarSiteDef||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaScalarSiteDef\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaScalarSiteDef(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaScalarSiteDef||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaScalarSiteDef\n"
"  Paramegers: (oaObserver_oaScalarSiteDef)\n"
"    Calls: (const oaObserver_oaScalarSiteDef&)\n"
"    Signature: oaObserver_oaScalarSiteDef||cref-oaObserver_oaScalarSiteDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaScalarSiteDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaScalarSiteDef",
    sizeof(PyoaObserver_oaScalarSiteDefObject),
    0,
    (destructor)oaObserver_oaScalarSiteDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaScalarSiteDef_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaScalarSiteDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaScalarSiteDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaScalarSiteDef_oaSiteDefModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaScalarSiteDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaScalarSiteDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaScalarSiteDef_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaScalarSiteDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaScalarSiteDef",
           (PyObject*)(&PyoaObserver_oaScalarSiteDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaScalarSiteDef\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaScalarTerm
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaScalarTerm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaScalarTerm_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaScalarTermObject* self = (PyoaObserver_oaScalarTermObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaScalarTerm(p1.Data());
            }
            else {
                pyv_oaObserver_oaScalarTerm* p=new pyv_oaObserver_oaScalarTerm(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaScalarTerm(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaScalarTerm* p=new pyv_oaObserver_oaScalarTerm(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaScalarTerm)
    {
        PyParamoaObserver_oaScalarTerm p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaScalarTerm_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaScalarTerm(p1.Data());
            }
            else {
                pyv_oaObserver_oaScalarTerm* p=new pyv_oaObserver_oaScalarTerm(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaScalarTerm, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaScalarTerm)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaScalarTerm_tp_dealloc(PyoaObserver_oaScalarTermObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaScalarTerm*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaScalarTerm_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaScalarTerm value;
    int convert_status=PyoaObserver_oaScalarTerm_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaObserver_oaScalarTerm::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaScalarTerm_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaScalarTerm v1;
    PyParamoaObserver_oaScalarTerm v2;
    int convert_status1=PyoaObserver_oaScalarTerm_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaScalarTerm_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaScalarTerm_Convert(PyObject* ob,PyParamoaObserver_oaScalarTerm* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaScalarTerm_Check(ob)) {
        result->SetData( (oaObserver_oaScalarTerm*) ((PyoaObserver_oaScalarTermObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaScalarTerm Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaScalarTerm_FromoaObserver_oaScalarTerm(oaObserver_oaScalarTerm* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaScalarTerm_Type.tp_alloc(&PyoaObserver_oaScalarTerm_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaScalarTermObject* self = (PyoaObserver_oaScalarTermObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaScalarTerm::pyv_oaObserver_oaScalarTerm(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaScalarTerm(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaScalarTerm::pyv_oaObserver_oaScalarTerm(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaScalarTerm(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaScalarTerm::pyv_oaObserver_oaScalarTerm(const oaObserver_oaScalarTerm& p)
 : pyob(NULL),
   oaObserver_oaScalarTerm(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScalarTerm::onPostCreate(oaScalarTerm* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarTerm::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaScalarTerm_FromoaScalarTerm(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarTerm::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScalarTerm::onPostModify(oaScalarTerm* p1,oaTermModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarTerm::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaScalarTerm_FromoaScalarTerm(p1));
    PyTuple_SetItem(args,1,PyoaTermModTypeEnum_FromoaTermModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarTerm::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScalarTerm::onPreDestroy(oaScalarTerm* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarTerm::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaScalarTerm_FromoaScalarTerm(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarTerm::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScalarTerm::onPreModify(oaScalarTerm* p1,oaTermModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarTerm::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaScalarTerm_FromoaScalarTerm(p1));
    PyTuple_SetItem(args,1,PyoaTermModTypeEnum_FromoaTermModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScalarTerm::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaScalarTerm_doc[] = 
"Class: oaObserver_oaScalarTerm\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaScalarTerm(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaScalarTerm||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaScalarTerm\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaScalarTerm(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaScalarTerm||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaScalarTerm\n"
"  Paramegers: (oaObserver_oaScalarTerm)\n"
"    Calls: (const oaObserver_oaScalarTerm&)\n"
"    Signature: oaObserver_oaScalarTerm||cref-oaObserver_oaScalarTerm,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaScalarTerm_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaScalarTerm",
    sizeof(PyoaObserver_oaScalarTermObject),
    0,
    (destructor)oaObserver_oaScalarTerm_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaScalarTerm_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaScalarTerm_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaScalarTerm_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaScalarTerm_oaTermModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaScalarTerm_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaScalarTerm_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaScalarTerm_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaScalarTerm\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaScalarTerm",
           (PyObject*)(&PyoaObserver_oaScalarTerm_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaScalarTerm\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaScanChain
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaScanChain_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaScanChain_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaScanChainObject* self = (PyoaObserver_oaScanChainObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaScanChain(p1.Data());
            }
            else {
                pyv_oaObserver_oaScanChain* p=new pyv_oaObserver_oaScanChain(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaScanChain(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaScanChain* p=new pyv_oaObserver_oaScanChain(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaScanChain)
    {
        PyParamoaObserver_oaScanChain p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaScanChain_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaScanChain(p1.Data());
            }
            else {
                pyv_oaObserver_oaScanChain* p=new pyv_oaObserver_oaScanChain(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaScanChain, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaScanChain)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaScanChain_tp_dealloc(PyoaObserver_oaScanChainObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaScanChain*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaScanChain_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaScanChain value;
    int convert_status=PyoaObserver_oaScanChain_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaObserver_oaScanChain::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaScanChain_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaScanChain v1;
    PyParamoaObserver_oaScanChain v2;
    int convert_status1=PyoaObserver_oaScanChain_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaScanChain_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaScanChain_Convert(PyObject* ob,PyParamoaObserver_oaScanChain* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaScanChain_Check(ob)) {
        result->SetData( (oaObserver_oaScanChain*) ((PyoaObserver_oaScanChainObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaScanChain Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaScanChain_FromoaObserver_oaScanChain(oaObserver_oaScanChain* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaScanChain_Type.tp_alloc(&PyoaObserver_oaScanChain_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaScanChainObject* self = (PyoaObserver_oaScanChainObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaScanChain::pyv_oaObserver_oaScanChain(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaScanChain(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaScanChain::pyv_oaObserver_oaScanChain(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaScanChain(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaScanChain::pyv_oaObserver_oaScanChain(const oaObserver_oaScanChain& p)
 : pyob(NULL),
   oaObserver_oaScanChain(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScanChain::onPostCreate(oaScanChain* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChain::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaScanChain_FromoaScanChain(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChain::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScanChain::onPostModify(oaScanChain* p1,oaScanChainModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChain::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaScanChain_FromoaScanChain(p1));
    PyTuple_SetItem(args,1,PyoaScanChainModTypeEnum_FromoaScanChainModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChain::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScanChain::onPreDestroy(oaScanChain* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChain::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaScanChain_FromoaScanChain(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChain::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScanChain::onPreModify(oaScanChain* p1,oaScanChainModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChain::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaScanChain_FromoaScanChain(p1));
    PyTuple_SetItem(args,1,PyoaScanChainModTypeEnum_FromoaScanChainModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChain::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaScanChain_doc[] = 
"Class: oaObserver_oaScanChain\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaScanChain(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaScanChain||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaScanChain\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaScanChain(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaScanChain||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaScanChain\n"
"  Paramegers: (oaObserver_oaScanChain)\n"
"    Calls: (const oaObserver_oaScanChain&)\n"
"    Signature: oaObserver_oaScanChain||cref-oaObserver_oaScanChain,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaScanChain_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaScanChain",
    sizeof(PyoaObserver_oaScanChainObject),
    0,
    (destructor)oaObserver_oaScanChain_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaScanChain_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaScanChain_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaScanChain_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaScanChain_oaScanChainModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaScanChain_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaScanChain_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaScanChain_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaScanChain\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaScanChain",
           (PyObject*)(&PyoaObserver_oaScanChain_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaScanChain\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaScanChainInst
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaScanChainInst_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaScanChainInst_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaScanChainInstObject* self = (PyoaObserver_oaScanChainInstObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaScanChainInst(p1.Data());
            }
            else {
                pyv_oaObserver_oaScanChainInst* p=new pyv_oaObserver_oaScanChainInst(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaScanChainInst(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaScanChainInst* p=new pyv_oaObserver_oaScanChainInst(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaScanChainInst)
    {
        PyParamoaObserver_oaScanChainInst p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaScanChainInst_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaScanChainInst(p1.Data());
            }
            else {
                pyv_oaObserver_oaScanChainInst* p=new pyv_oaObserver_oaScanChainInst(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaScanChainInst, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaScanChainInst)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaScanChainInst_tp_dealloc(PyoaObserver_oaScanChainInstObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaScanChainInst*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaScanChainInst_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaScanChainInst value;
    int convert_status=PyoaObserver_oaScanChainInst_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[48];
    sprintf(buffer,"<oaObserver_oaScanChainInst::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaScanChainInst_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaScanChainInst v1;
    PyParamoaObserver_oaScanChainInst v2;
    int convert_status1=PyoaObserver_oaScanChainInst_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaScanChainInst_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaScanChainInst_Convert(PyObject* ob,PyParamoaObserver_oaScanChainInst* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaScanChainInst_Check(ob)) {
        result->SetData( (oaObserver_oaScanChainInst*) ((PyoaObserver_oaScanChainInstObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaScanChainInst Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaScanChainInst_FromoaObserver_oaScanChainInst(oaObserver_oaScanChainInst* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaScanChainInst_Type.tp_alloc(&PyoaObserver_oaScanChainInst_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaScanChainInstObject* self = (PyoaObserver_oaScanChainInstObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaScanChainInst::pyv_oaObserver_oaScanChainInst(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaScanChainInst(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaScanChainInst::pyv_oaObserver_oaScanChainInst(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaScanChainInst(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaScanChainInst::pyv_oaObserver_oaScanChainInst(const oaObserver_oaScanChainInst& p)
 : pyob(NULL),
   oaObserver_oaScanChainInst(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScanChainInst::onPostCreate(oaScanChainInst* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChainInst::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaScanChainInst_FromoaScanChainInst(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChainInst::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScanChainInst::onPostModify(oaScanChainInst* p1,oaScanChainInstModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChainInst::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaScanChainInst_FromoaScanChainInst(p1));
    PyTuple_SetItem(args,1,PyoaScanChainInstModTypeEnum_FromoaScanChainInstModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChainInst::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScanChainInst::onPreDestroy(oaScanChainInst* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChainInst::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaScanChainInst_FromoaScanChainInst(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChainInst::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScanChainInst::onPreModify(oaScanChainInst* p1,oaScanChainInstModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChainInst::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaScanChainInst_FromoaScanChainInst(p1));
    PyTuple_SetItem(args,1,PyoaScanChainInstModTypeEnum_FromoaScanChainInstModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChainInst::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaScanChainInst_doc[] = 
"Class: oaObserver_oaScanChainInst\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaScanChainInst(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaScanChainInst||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaScanChainInst\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaScanChainInst(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaScanChainInst||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaScanChainInst\n"
"  Paramegers: (oaObserver_oaScanChainInst)\n"
"    Calls: (const oaObserver_oaScanChainInst&)\n"
"    Signature: oaObserver_oaScanChainInst||cref-oaObserver_oaScanChainInst,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaScanChainInst_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaScanChainInst",
    sizeof(PyoaObserver_oaScanChainInstObject),
    0,
    (destructor)oaObserver_oaScanChainInst_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaScanChainInst_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaScanChainInst_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaScanChainInst_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaScanChainInst_oaScanChainInstModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaScanChainInst_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaScanChainInst_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaScanChainInst_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaScanChainInst\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaScanChainInst",
           (PyObject*)(&PyoaObserver_oaScanChainInst_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaScanChainInst\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaScanChainSet
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaScanChainSet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaScanChainSet_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaScanChainSetObject* self = (PyoaObserver_oaScanChainSetObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaScanChainSet(p1.Data());
            }
            else {
                pyv_oaObserver_oaScanChainSet* p=new pyv_oaObserver_oaScanChainSet(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaScanChainSet(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaScanChainSet* p=new pyv_oaObserver_oaScanChainSet(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaScanChainSet)
    {
        PyParamoaObserver_oaScanChainSet p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaScanChainSet_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaScanChainSet(p1.Data());
            }
            else {
                pyv_oaObserver_oaScanChainSet* p=new pyv_oaObserver_oaScanChainSet(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaScanChainSet, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaScanChainSet)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaScanChainSet_tp_dealloc(PyoaObserver_oaScanChainSetObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaScanChainSet*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaScanChainSet_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaScanChainSet value;
    int convert_status=PyoaObserver_oaScanChainSet_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[47];
    sprintf(buffer,"<oaObserver_oaScanChainSet::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaScanChainSet_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaScanChainSet v1;
    PyParamoaObserver_oaScanChainSet v2;
    int convert_status1=PyoaObserver_oaScanChainSet_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaScanChainSet_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaScanChainSet_Convert(PyObject* ob,PyParamoaObserver_oaScanChainSet* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaScanChainSet_Check(ob)) {
        result->SetData( (oaObserver_oaScanChainSet*) ((PyoaObserver_oaScanChainSetObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaScanChainSet Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaScanChainSet_FromoaObserver_oaScanChainSet(oaObserver_oaScanChainSet* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaScanChainSet_Type.tp_alloc(&PyoaObserver_oaScanChainSet_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaScanChainSetObject* self = (PyoaObserver_oaScanChainSetObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaScanChainSet::pyv_oaObserver_oaScanChainSet(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaScanChainSet(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaScanChainSet::pyv_oaObserver_oaScanChainSet(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaScanChainSet(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaScanChainSet::pyv_oaObserver_oaScanChainSet(const oaObserver_oaScanChainSet& p)
 : pyob(NULL),
   oaObserver_oaScanChainSet(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScanChainSet::onPostCreate(oaScanChainSet* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChainSet::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaScanChainSet_FromoaScanChainSet(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChainSet::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScanChainSet::onPostModify(oaScanChainSet* p1,oaScanChainSetModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChainSet::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaScanChainSet_FromoaScanChainSet(p1));
    PyTuple_SetItem(args,1,PyoaScanChainSetModTypeEnum_FromoaScanChainSetModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChainSet::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScanChainSet::onPreDestroy(oaScanChainSet* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChainSet::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaScanChainSet_FromoaScanChainSet(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChainSet::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaScanChainSet::onPreModify(oaScanChainSet* p1,oaScanChainSetModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChainSet::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaScanChainSet_FromoaScanChainSet(p1));
    PyTuple_SetItem(args,1,PyoaScanChainSetModTypeEnum_FromoaScanChainSetModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaScanChainSet::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaScanChainSet_doc[] = 
"Class: oaObserver_oaScanChainSet\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaScanChainSet(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaScanChainSet||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaScanChainSet\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaScanChainSet(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaScanChainSet||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaScanChainSet\n"
"  Paramegers: (oaObserver_oaScanChainSet)\n"
"    Calls: (const oaObserver_oaScanChainSet&)\n"
"    Signature: oaObserver_oaScanChainSet||cref-oaObserver_oaScanChainSet,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaScanChainSet_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaScanChainSet",
    sizeof(PyoaObserver_oaScanChainSetObject),
    0,
    (destructor)oaObserver_oaScanChainSet_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaScanChainSet_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaScanChainSet_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaScanChainSet_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaScanChainSet_oaScanChainSetModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaScanChainSet_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaScanChainSet_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaScanChainSet_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaScanChainSet\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaScanChainSet",
           (PyObject*)(&PyoaObserver_oaScanChainSet_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaScanChainSet\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaSeriesRL
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaSeriesRL_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaSeriesRL_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaSeriesRLObject* self = (PyoaObserver_oaSeriesRLObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaSeriesRL(p1.Data());
            }
            else {
                pyv_oaObserver_oaSeriesRL* p=new pyv_oaObserver_oaSeriesRL(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaSeriesRL(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaSeriesRL* p=new pyv_oaObserver_oaSeriesRL(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaSeriesRL)
    {
        PyParamoaObserver_oaSeriesRL p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaSeriesRL_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaSeriesRL(p1.Data());
            }
            else {
                pyv_oaObserver_oaSeriesRL* p=new pyv_oaObserver_oaSeriesRL(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaSeriesRL, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaSeriesRL)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaSeriesRL_tp_dealloc(PyoaObserver_oaSeriesRLObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaSeriesRL*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaSeriesRL_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaSeriesRL value;
    int convert_status=PyoaObserver_oaSeriesRL_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[43];
    sprintf(buffer,"<oaObserver_oaSeriesRL::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaSeriesRL_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaSeriesRL v1;
    PyParamoaObserver_oaSeriesRL v2;
    int convert_status1=PyoaObserver_oaSeriesRL_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaSeriesRL_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaSeriesRL_Convert(PyObject* ob,PyParamoaObserver_oaSeriesRL* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaSeriesRL_Check(ob)) {
        result->SetData( (oaObserver_oaSeriesRL*) ((PyoaObserver_oaSeriesRLObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaSeriesRL Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaSeriesRL_FromoaObserver_oaSeriesRL(oaObserver_oaSeriesRL* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaSeriesRL_Type.tp_alloc(&PyoaObserver_oaSeriesRL_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaSeriesRLObject* self = (PyoaObserver_oaSeriesRLObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaSeriesRL::pyv_oaObserver_oaSeriesRL(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaSeriesRL(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaSeriesRL::pyv_oaObserver_oaSeriesRL(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaSeriesRL(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaSeriesRL::pyv_oaObserver_oaSeriesRL(const oaObserver_oaSeriesRL& p)
 : pyob(NULL),
   oaObserver_oaSeriesRL(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSeriesRL::onPostCreate(oaSeriesRL* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSeriesRL::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaSeriesRL_FromoaSeriesRL(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSeriesRL::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSeriesRL::onPostModify(oaSeriesRL* p1,oaDeviceModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSeriesRL::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaSeriesRL_FromoaSeriesRL(p1));
    PyTuple_SetItem(args,1,PyoaDeviceModTypeEnum_FromoaDeviceModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSeriesRL::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSeriesRL::onPreDestroy(oaSeriesRL* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSeriesRL::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaSeriesRL_FromoaSeriesRL(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSeriesRL::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSeriesRL::onPreModify(oaSeriesRL* p1,oaDeviceModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSeriesRL::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaSeriesRL_FromoaSeriesRL(p1));
    PyTuple_SetItem(args,1,PyoaDeviceModTypeEnum_FromoaDeviceModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSeriesRL::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaSeriesRL_doc[] = 
"Class: oaObserver_oaSeriesRL\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaSeriesRL(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaSeriesRL||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaSeriesRL\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaSeriesRL(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaSeriesRL||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaSeriesRL\n"
"  Paramegers: (oaObserver_oaSeriesRL)\n"
"    Calls: (const oaObserver_oaSeriesRL&)\n"
"    Signature: oaObserver_oaSeriesRL||cref-oaObserver_oaSeriesRL,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaSeriesRL_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaSeriesRL",
    sizeof(PyoaObserver_oaSeriesRLObject),
    0,
    (destructor)oaObserver_oaSeriesRL_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaSeriesRL_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaSeriesRL_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaSeriesRL_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaSeriesRL_oaDeviceModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaSeriesRL_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaSeriesRL_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaSeriesRL_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaSeriesRL\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaSeriesRL",
           (PyObject*)(&PyoaObserver_oaSeriesRL_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaSeriesRL\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaShape
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaShape_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaShape_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaShapeObject* self = (PyoaObserver_oaShapeObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaShape(p1.Data());
            }
            else {
                pyv_oaObserver_oaShape* p=new pyv_oaObserver_oaShape(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaShape(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaShape* p=new pyv_oaObserver_oaShape(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaShape)
    {
        PyParamoaObserver_oaShape p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaShape_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaShape(p1.Data());
            }
            else {
                pyv_oaObserver_oaShape* p=new pyv_oaObserver_oaShape(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaShape, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaShape)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaShape_tp_dealloc(PyoaObserver_oaShapeObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaShape*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaShape_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaShape value;
    int convert_status=PyoaObserver_oaShape_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[40];
    sprintf(buffer,"<oaObserver_oaShape::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaShape_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaShape v1;
    PyParamoaObserver_oaShape v2;
    int convert_status1=PyoaObserver_oaShape_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaShape_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaShape_Convert(PyObject* ob,PyParamoaObserver_oaShape* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaShape_Check(ob)) {
        result->SetData( (oaObserver_oaShape*) ((PyoaObserver_oaShapeObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaShape Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaShape_FromoaObserver_oaShape(oaObserver_oaShape* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaShape_Type.tp_alloc(&PyoaObserver_oaShape_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaShapeObject* self = (PyoaObserver_oaShapeObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaShape::pyv_oaObserver_oaShape(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaShape(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaShape::pyv_oaObserver_oaShape(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaShape(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaShape::pyv_oaObserver_oaShape(const oaObserver_oaShape& p)
 : pyob(NULL),
   oaObserver_oaShape(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaShape::onPostCreate(oaShape* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaShape::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaShape_FromoaShape(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaShape::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaShape::onPostModify(oaShape* p1,oaShapeModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaShape::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaShape_FromoaShape(p1));
    PyTuple_SetItem(args,1,PyoaShapeModTypeEnum_FromoaShapeModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaShape::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaShape::onPreDestroy(oaShape* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaShape::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaShape_FromoaShape(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaShape::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaShape::onPreModify(oaShape* p1,oaShapeModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaShape::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaShape_FromoaShape(p1));
    PyTuple_SetItem(args,1,PyoaShapeModTypeEnum_FromoaShapeModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaShape::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaShape_doc[] = 
"Class: oaObserver_oaShape\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaShape(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaShape||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaShape\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaShape(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaShape||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaShape\n"
"  Paramegers: (oaObserver_oaShape)\n"
"    Calls: (const oaObserver_oaShape&)\n"
"    Signature: oaObserver_oaShape||cref-oaObserver_oaShape,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaShape_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaShape",
    sizeof(PyoaObserver_oaShapeObject),
    0,
    (destructor)oaObserver_oaShape_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaShape_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaShape_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaShape_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaShape_oaShapeModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaShape_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaShape_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaShape_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaShape\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaShape",
           (PyObject*)(&PyoaObserver_oaShape_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaShape\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaSimpleConstraint
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaSimpleConstraint_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaSimpleConstraint_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaSimpleConstraintObject* self = (PyoaObserver_oaSimpleConstraintObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaSimpleConstraint(p1.Data());
            }
            else {
                pyv_oaObserver_oaSimpleConstraint* p=new pyv_oaObserver_oaSimpleConstraint(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaSimpleConstraint(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaSimpleConstraint* p=new pyv_oaObserver_oaSimpleConstraint(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaSimpleConstraint)
    {
        PyParamoaObserver_oaSimpleConstraint p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaSimpleConstraint_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaSimpleConstraint(p1.Data());
            }
            else {
                pyv_oaObserver_oaSimpleConstraint* p=new pyv_oaObserver_oaSimpleConstraint(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaSimpleConstraint, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaSimpleConstraint)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaSimpleConstraint_tp_dealloc(PyoaObserver_oaSimpleConstraintObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaSimpleConstraint*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaSimpleConstraint_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaSimpleConstraint value;
    int convert_status=PyoaObserver_oaSimpleConstraint_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[51];
    sprintf(buffer,"<oaObserver_oaSimpleConstraint::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaSimpleConstraint_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaSimpleConstraint v1;
    PyParamoaObserver_oaSimpleConstraint v2;
    int convert_status1=PyoaObserver_oaSimpleConstraint_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaSimpleConstraint_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaSimpleConstraint_Convert(PyObject* ob,PyParamoaObserver_oaSimpleConstraint* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaSimpleConstraint_Check(ob)) {
        result->SetData( (oaObserver_oaSimpleConstraint*) ((PyoaObserver_oaSimpleConstraintObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaSimpleConstraint Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaSimpleConstraint_FromoaObserver_oaSimpleConstraint(oaObserver_oaSimpleConstraint* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaSimpleConstraint_Type.tp_alloc(&PyoaObserver_oaSimpleConstraint_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaSimpleConstraintObject* self = (PyoaObserver_oaSimpleConstraintObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaSimpleConstraint::pyv_oaObserver_oaSimpleConstraint(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaSimpleConstraint(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaSimpleConstraint::pyv_oaObserver_oaSimpleConstraint(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaSimpleConstraint(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaSimpleConstraint::pyv_oaObserver_oaSimpleConstraint(const oaObserver_oaSimpleConstraint& p)
 : pyob(NULL),
   oaObserver_oaSimpleConstraint(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSimpleConstraint::onPostCreate(oaSimpleConstraint* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSimpleConstraint::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaSimpleConstraint_FromoaSimpleConstraint(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSimpleConstraint::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSimpleConstraint::onPostModify(oaSimpleConstraint* p1,oaConstraintModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSimpleConstraint::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaSimpleConstraint_FromoaSimpleConstraint(p1));
    PyTuple_SetItem(args,1,PyoaConstraintModTypeEnum_FromoaConstraintModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSimpleConstraint::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSimpleConstraint::onPreDestroy(oaSimpleConstraint* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSimpleConstraint::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaSimpleConstraint_FromoaSimpleConstraint(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSimpleConstraint::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSimpleConstraint::onPreModify(oaSimpleConstraint* p1,oaConstraintModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSimpleConstraint::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaSimpleConstraint_FromoaSimpleConstraint(p1));
    PyTuple_SetItem(args,1,PyoaConstraintModTypeEnum_FromoaConstraintModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSimpleConstraint::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaSimpleConstraint_doc[] = 
"Class: oaObserver_oaSimpleConstraint\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaSimpleConstraint(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaSimpleConstraint||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaSimpleConstraint\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaSimpleConstraint(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaSimpleConstraint||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaSimpleConstraint\n"
"  Paramegers: (oaObserver_oaSimpleConstraint)\n"
"    Calls: (const oaObserver_oaSimpleConstraint&)\n"
"    Signature: oaObserver_oaSimpleConstraint||cref-oaObserver_oaSimpleConstraint,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaSimpleConstraint_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaSimpleConstraint",
    sizeof(PyoaObserver_oaSimpleConstraintObject),
    0,
    (destructor)oaObserver_oaSimpleConstraint_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaSimpleConstraint_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaSimpleConstraint_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaSimpleConstraint_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaSimpleConstraint_oaConstraintModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaSimpleConstraint_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaSimpleConstraint_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaSimpleConstraint_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaSimpleConstraint\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaSimpleConstraint",
           (PyObject*)(&PyoaObserver_oaSimpleConstraint_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaSimpleConstraint\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaSiteDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaSiteDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaSiteDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaSiteDefObject* self = (PyoaObserver_oaSiteDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaSiteDef(p1.Data());
            }
            else {
                pyv_oaObserver_oaSiteDef* p=new pyv_oaObserver_oaSiteDef(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaSiteDef(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaSiteDef* p=new pyv_oaObserver_oaSiteDef(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaSiteDef)
    {
        PyParamoaObserver_oaSiteDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaSiteDef_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaSiteDef(p1.Data());
            }
            else {
                pyv_oaObserver_oaSiteDef* p=new pyv_oaObserver_oaSiteDef(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaSiteDef, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaSiteDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaSiteDef_tp_dealloc(PyoaObserver_oaSiteDefObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaSiteDef*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaSiteDef_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaSiteDef value;
    int convert_status=PyoaObserver_oaSiteDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaObserver_oaSiteDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaSiteDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaSiteDef v1;
    PyParamoaObserver_oaSiteDef v2;
    int convert_status1=PyoaObserver_oaSiteDef_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaSiteDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaSiteDef_Convert(PyObject* ob,PyParamoaObserver_oaSiteDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaSiteDef_Check(ob)) {
        result->SetData( (oaObserver_oaSiteDef*) ((PyoaObserver_oaSiteDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaSiteDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaSiteDef_FromoaObserver_oaSiteDef(oaObserver_oaSiteDef* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaSiteDef_Type.tp_alloc(&PyoaObserver_oaSiteDef_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaSiteDefObject* self = (PyoaObserver_oaSiteDefObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaSiteDef::pyv_oaObserver_oaSiteDef(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaSiteDef(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaSiteDef::pyv_oaObserver_oaSiteDef(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaSiteDef(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaSiteDef::pyv_oaObserver_oaSiteDef(const oaObserver_oaSiteDef& p)
 : pyob(NULL),
   oaObserver_oaSiteDef(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSiteDef::onPostCreate(oaSiteDef* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSiteDef::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaSiteDef_FromoaSiteDef(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSiteDef::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSiteDef::onPostModify(oaSiteDef* p1,oaSiteDefModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSiteDef::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaSiteDef_FromoaSiteDef(p1));
    PyTuple_SetItem(args,1,PyoaSiteDefModTypeEnum_FromoaSiteDefModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSiteDef::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSiteDef::onPreDestroy(oaSiteDef* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSiteDef::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaSiteDef_FromoaSiteDef(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSiteDef::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSiteDef::onPreModify(oaSiteDef* p1,oaSiteDefModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSiteDef::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaSiteDef_FromoaSiteDef(p1));
    PyTuple_SetItem(args,1,PyoaSiteDefModTypeEnum_FromoaSiteDefModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSiteDef::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaSiteDef_doc[] = 
"Class: oaObserver_oaSiteDef\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaSiteDef(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaSiteDef||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaSiteDef\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaSiteDef(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaSiteDef||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaSiteDef\n"
"  Paramegers: (oaObserver_oaSiteDef)\n"
"    Calls: (const oaObserver_oaSiteDef&)\n"
"    Signature: oaObserver_oaSiteDef||cref-oaObserver_oaSiteDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaSiteDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaSiteDef",
    sizeof(PyoaObserver_oaSiteDefObject),
    0,
    (destructor)oaObserver_oaSiteDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaSiteDef_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaSiteDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaSiteDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaSiteDef_oaSiteDefModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaSiteDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaSiteDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaSiteDef_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaSiteDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaSiteDef",
           (PyObject*)(&PyoaObserver_oaSiteDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaSiteDef\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaSizedLayer
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaSizedLayer_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaSizedLayer_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaSizedLayerObject* self = (PyoaObserver_oaSizedLayerObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaSizedLayer(p1.Data());
            }
            else {
                pyv_oaObserver_oaSizedLayer* p=new pyv_oaObserver_oaSizedLayer(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaSizedLayer(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaSizedLayer* p=new pyv_oaObserver_oaSizedLayer(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaSizedLayer)
    {
        PyParamoaObserver_oaSizedLayer p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaSizedLayer_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaSizedLayer(p1.Data());
            }
            else {
                pyv_oaObserver_oaSizedLayer* p=new pyv_oaObserver_oaSizedLayer(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaSizedLayer, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaSizedLayer)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaSizedLayer_tp_dealloc(PyoaObserver_oaSizedLayerObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaSizedLayer*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaSizedLayer_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaSizedLayer value;
    int convert_status=PyoaObserver_oaSizedLayer_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaObserver_oaSizedLayer::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaSizedLayer_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaSizedLayer v1;
    PyParamoaObserver_oaSizedLayer v2;
    int convert_status1=PyoaObserver_oaSizedLayer_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaSizedLayer_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaSizedLayer_Convert(PyObject* ob,PyParamoaObserver_oaSizedLayer* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaSizedLayer_Check(ob)) {
        result->SetData( (oaObserver_oaSizedLayer*) ((PyoaObserver_oaSizedLayerObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaSizedLayer Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaSizedLayer_FromoaObserver_oaSizedLayer(oaObserver_oaSizedLayer* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaSizedLayer_Type.tp_alloc(&PyoaObserver_oaSizedLayer_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaSizedLayerObject* self = (PyoaObserver_oaSizedLayerObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaSizedLayer::pyv_oaObserver_oaSizedLayer(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaSizedLayer(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaSizedLayer::pyv_oaObserver_oaSizedLayer(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaSizedLayer(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaSizedLayer::pyv_oaObserver_oaSizedLayer(const oaObserver_oaSizedLayer& p)
 : pyob(NULL),
   oaObserver_oaSizedLayer(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSizedLayer::onPostCreate(oaSizedLayer* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSizedLayer::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaSizedLayer_FromoaSizedLayer(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSizedLayer::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSizedLayer::onPostModify(oaSizedLayer* p1,oaLayerModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSizedLayer::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaSizedLayer_FromoaSizedLayer(p1));
    PyTuple_SetItem(args,1,PyoaLayerModTypeEnum_FromoaLayerModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSizedLayer::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSizedLayer::onPreDestroy(oaSizedLayer* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSizedLayer::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaSizedLayer_FromoaSizedLayer(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSizedLayer::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSizedLayer::onPreModify(oaSizedLayer* p1,oaLayerModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSizedLayer::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaSizedLayer_FromoaSizedLayer(p1));
    PyTuple_SetItem(args,1,PyoaLayerModTypeEnum_FromoaLayerModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSizedLayer::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaSizedLayer_doc[] = 
"Class: oaObserver_oaSizedLayer\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaSizedLayer(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaSizedLayer||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaSizedLayer\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaSizedLayer(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaSizedLayer||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaSizedLayer\n"
"  Paramegers: (oaObserver_oaSizedLayer)\n"
"    Calls: (const oaObserver_oaSizedLayer&)\n"
"    Signature: oaObserver_oaSizedLayer||cref-oaObserver_oaSizedLayer,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaSizedLayer_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaSizedLayer",
    sizeof(PyoaObserver_oaSizedLayerObject),
    0,
    (destructor)oaObserver_oaSizedLayer_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaSizedLayer_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaSizedLayer_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaSizedLayer_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaSizedLayer_oaLayerModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaSizedLayer_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaSizedLayer_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaSizedLayer_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaSizedLayer\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaSizedLayer",
           (PyObject*)(&PyoaObserver_oaSizedLayer_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaSizedLayer\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaSnapBoundary
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaSnapBoundary_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaSnapBoundary_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaSnapBoundaryObject* self = (PyoaObserver_oaSnapBoundaryObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaSnapBoundary(p1.Data());
            }
            else {
                pyv_oaObserver_oaSnapBoundary* p=new pyv_oaObserver_oaSnapBoundary(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaSnapBoundary(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaSnapBoundary* p=new pyv_oaObserver_oaSnapBoundary(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaSnapBoundary)
    {
        PyParamoaObserver_oaSnapBoundary p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaSnapBoundary_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaSnapBoundary(p1.Data());
            }
            else {
                pyv_oaObserver_oaSnapBoundary* p=new pyv_oaObserver_oaSnapBoundary(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaSnapBoundary, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaSnapBoundary)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaSnapBoundary_tp_dealloc(PyoaObserver_oaSnapBoundaryObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaSnapBoundary*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaSnapBoundary_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaSnapBoundary value;
    int convert_status=PyoaObserver_oaSnapBoundary_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[47];
    sprintf(buffer,"<oaObserver_oaSnapBoundary::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaSnapBoundary_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaSnapBoundary v1;
    PyParamoaObserver_oaSnapBoundary v2;
    int convert_status1=PyoaObserver_oaSnapBoundary_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaSnapBoundary_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaSnapBoundary_Convert(PyObject* ob,PyParamoaObserver_oaSnapBoundary* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaSnapBoundary_Check(ob)) {
        result->SetData( (oaObserver_oaSnapBoundary*) ((PyoaObserver_oaSnapBoundaryObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaSnapBoundary Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaSnapBoundary_FromoaObserver_oaSnapBoundary(oaObserver_oaSnapBoundary* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaSnapBoundary_Type.tp_alloc(&PyoaObserver_oaSnapBoundary_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaSnapBoundaryObject* self = (PyoaObserver_oaSnapBoundaryObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaSnapBoundary::pyv_oaObserver_oaSnapBoundary(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaSnapBoundary(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaSnapBoundary::pyv_oaObserver_oaSnapBoundary(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaSnapBoundary(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaSnapBoundary::pyv_oaObserver_oaSnapBoundary(const oaObserver_oaSnapBoundary& p)
 : pyob(NULL),
   oaObserver_oaSnapBoundary(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSnapBoundary::onPostCreate(oaSnapBoundary* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSnapBoundary::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaSnapBoundary_FromoaSnapBoundary(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSnapBoundary::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSnapBoundary::onPostModify(oaSnapBoundary* p1,oaBoundaryModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSnapBoundary::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaSnapBoundary_FromoaSnapBoundary(p1));
    PyTuple_SetItem(args,1,PyoaBoundaryModTypeEnum_FromoaBoundaryModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSnapBoundary::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSnapBoundary::onPreDestroy(oaSnapBoundary* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSnapBoundary::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaSnapBoundary_FromoaSnapBoundary(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSnapBoundary::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSnapBoundary::onPreModify(oaSnapBoundary* p1,oaBoundaryModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSnapBoundary::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaSnapBoundary_FromoaSnapBoundary(p1));
    PyTuple_SetItem(args,1,PyoaBoundaryModTypeEnum_FromoaBoundaryModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSnapBoundary::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaSnapBoundary_doc[] = 
"Class: oaObserver_oaSnapBoundary\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaSnapBoundary(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaSnapBoundary||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaSnapBoundary\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaSnapBoundary(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaSnapBoundary||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaSnapBoundary\n"
"  Paramegers: (oaObserver_oaSnapBoundary)\n"
"    Calls: (const oaObserver_oaSnapBoundary&)\n"
"    Signature: oaObserver_oaSnapBoundary||cref-oaObserver_oaSnapBoundary,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaSnapBoundary_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaSnapBoundary",
    sizeof(PyoaObserver_oaSnapBoundaryObject),
    0,
    (destructor)oaObserver_oaSnapBoundary_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaSnapBoundary_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaSnapBoundary_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaSnapBoundary_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaSnapBoundary_oaBoundaryModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaSnapBoundary_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaSnapBoundary_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaSnapBoundary_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaSnapBoundary\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaSnapBoundary",
           (PyObject*)(&PyoaObserver_oaSnapBoundary_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaSnapBoundary\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaStdDevice
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaStdDevice_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaStdDevice_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaStdDeviceObject* self = (PyoaObserver_oaStdDeviceObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaStdDevice(p1.Data());
            }
            else {
                pyv_oaObserver_oaStdDevice* p=new pyv_oaObserver_oaStdDevice(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaStdDevice(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaStdDevice* p=new pyv_oaObserver_oaStdDevice(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaStdDevice)
    {
        PyParamoaObserver_oaStdDevice p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaStdDevice_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaStdDevice(p1.Data());
            }
            else {
                pyv_oaObserver_oaStdDevice* p=new pyv_oaObserver_oaStdDevice(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaStdDevice, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaStdDevice)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaStdDevice_tp_dealloc(PyoaObserver_oaStdDeviceObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaStdDevice*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaStdDevice_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaStdDevice value;
    int convert_status=PyoaObserver_oaStdDevice_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaObserver_oaStdDevice::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaStdDevice_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaStdDevice v1;
    PyParamoaObserver_oaStdDevice v2;
    int convert_status1=PyoaObserver_oaStdDevice_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaStdDevice_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaStdDevice_Convert(PyObject* ob,PyParamoaObserver_oaStdDevice* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaStdDevice_Check(ob)) {
        result->SetData( (oaObserver_oaStdDevice*) ((PyoaObserver_oaStdDeviceObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaStdDevice Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaStdDevice_FromoaObserver_oaStdDevice(oaObserver_oaStdDevice* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaStdDevice_Type.tp_alloc(&PyoaObserver_oaStdDevice_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaStdDeviceObject* self = (PyoaObserver_oaStdDeviceObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaStdDevice::pyv_oaObserver_oaStdDevice(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaStdDevice(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaStdDevice::pyv_oaObserver_oaStdDevice(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaStdDevice(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaStdDevice::pyv_oaObserver_oaStdDevice(const oaObserver_oaStdDevice& p)
 : pyob(NULL),
   oaObserver_oaStdDevice(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStdDevice::onPostCreate(oaStdDevice* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStdDevice::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaStdDevice_FromoaStdDevice(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStdDevice::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStdDevice::onPostModify(oaStdDevice* p1,oaDeviceModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStdDevice::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaStdDevice_FromoaStdDevice(p1));
    PyTuple_SetItem(args,1,PyoaDeviceModTypeEnum_FromoaDeviceModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStdDevice::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStdDevice::onPreDestroy(oaStdDevice* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStdDevice::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaStdDevice_FromoaStdDevice(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStdDevice::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStdDevice::onPreModify(oaStdDevice* p1,oaDeviceModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStdDevice::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaStdDevice_FromoaStdDevice(p1));
    PyTuple_SetItem(args,1,PyoaDeviceModTypeEnum_FromoaDeviceModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStdDevice::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaStdDevice_doc[] = 
"Class: oaObserver_oaStdDevice\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaStdDevice(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaStdDevice||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaStdDevice\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaStdDevice(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaStdDevice||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaStdDevice\n"
"  Paramegers: (oaObserver_oaStdDevice)\n"
"    Calls: (const oaObserver_oaStdDevice&)\n"
"    Signature: oaObserver_oaStdDevice||cref-oaObserver_oaStdDevice,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaStdDevice_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaStdDevice",
    sizeof(PyoaObserver_oaStdDeviceObject),
    0,
    (destructor)oaObserver_oaStdDevice_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaStdDevice_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaStdDevice_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaStdDevice_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaStdDevice_oaDeviceModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaStdDevice_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaStdDevice_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaStdDevice_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaStdDevice\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaStdDevice",
           (PyObject*)(&PyoaObserver_oaStdDevice_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaStdDevice\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaStdVia
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaStdVia_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaStdVia_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaStdViaObject* self = (PyoaObserver_oaStdViaObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaStdVia(p1.Data());
            }
            else {
                pyv_oaObserver_oaStdVia* p=new pyv_oaObserver_oaStdVia(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaStdVia(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaStdVia* p=new pyv_oaObserver_oaStdVia(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaStdVia)
    {
        PyParamoaObserver_oaStdVia p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaStdVia_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaStdVia(p1.Data());
            }
            else {
                pyv_oaObserver_oaStdVia* p=new pyv_oaObserver_oaStdVia(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaStdVia, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaStdVia)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaStdVia_tp_dealloc(PyoaObserver_oaStdViaObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaStdVia*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaStdVia_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaStdVia value;
    int convert_status=PyoaObserver_oaStdVia_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[41];
    sprintf(buffer,"<oaObserver_oaStdVia::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaStdVia_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaStdVia v1;
    PyParamoaObserver_oaStdVia v2;
    int convert_status1=PyoaObserver_oaStdVia_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaStdVia_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaStdVia_Convert(PyObject* ob,PyParamoaObserver_oaStdVia* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaStdVia_Check(ob)) {
        result->SetData( (oaObserver_oaStdVia*) ((PyoaObserver_oaStdViaObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaStdVia Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaStdVia_FromoaObserver_oaStdVia(oaObserver_oaStdVia* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaStdVia_Type.tp_alloc(&PyoaObserver_oaStdVia_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaStdViaObject* self = (PyoaObserver_oaStdViaObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaStdVia::pyv_oaObserver_oaStdVia(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaStdVia(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaStdVia::pyv_oaObserver_oaStdVia(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaStdVia(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaStdVia::pyv_oaObserver_oaStdVia(const oaObserver_oaStdVia& p)
 : pyob(NULL),
   oaObserver_oaStdVia(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStdVia::onPostCreate(oaStdVia* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStdVia::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaStdVia_FromoaStdVia(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStdVia::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStdVia::onPostModify(oaStdVia* p1,oaViaModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStdVia::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaStdVia_FromoaStdVia(p1));
    PyTuple_SetItem(args,1,PyoaViaModTypeEnum_FromoaViaModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStdVia::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStdVia::onPreDestroy(oaStdVia* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStdVia::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaStdVia_FromoaStdVia(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStdVia::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStdVia::onPreModify(oaStdVia* p1,oaViaModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStdVia::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaStdVia_FromoaStdVia(p1));
    PyTuple_SetItem(args,1,PyoaViaModTypeEnum_FromoaViaModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStdVia::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaStdVia_doc[] = 
"Class: oaObserver_oaStdVia\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaStdVia(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaStdVia||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaStdVia\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaStdVia(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaStdVia||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaStdVia\n"
"  Paramegers: (oaObserver_oaStdVia)\n"
"    Calls: (const oaObserver_oaStdVia&)\n"
"    Signature: oaObserver_oaStdVia||cref-oaObserver_oaStdVia,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaStdVia_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaStdVia",
    sizeof(PyoaObserver_oaStdViaObject),
    0,
    (destructor)oaObserver_oaStdVia_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaStdVia_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaStdVia_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaStdVia_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaStdVia_oaViaModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaStdVia_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaStdVia_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaStdVia_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaStdVia\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaStdVia",
           (PyObject*)(&PyoaObserver_oaStdVia_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaStdVia\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaStdViaDef
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaStdViaDef_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaStdViaDef_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaStdViaDefObject* self = (PyoaObserver_oaStdViaDefObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaStdViaDef(p1.Data());
            }
            else {
                pyv_oaObserver_oaStdViaDef* p=new pyv_oaObserver_oaStdViaDef(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaStdViaDef(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaStdViaDef* p=new pyv_oaObserver_oaStdViaDef(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaStdViaDef)
    {
        PyParamoaObserver_oaStdViaDef p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaStdViaDef_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaStdViaDef(p1.Data());
            }
            else {
                pyv_oaObserver_oaStdViaDef* p=new pyv_oaObserver_oaStdViaDef(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaStdViaDef, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaStdViaDef)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaStdViaDef_tp_dealloc(PyoaObserver_oaStdViaDefObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaStdViaDef*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaStdViaDef_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaStdViaDef value;
    int convert_status=PyoaObserver_oaStdViaDef_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[44];
    sprintf(buffer,"<oaObserver_oaStdViaDef::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaStdViaDef_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaStdViaDef v1;
    PyParamoaObserver_oaStdViaDef v2;
    int convert_status1=PyoaObserver_oaStdViaDef_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaStdViaDef_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaStdViaDef_Convert(PyObject* ob,PyParamoaObserver_oaStdViaDef* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaStdViaDef_Check(ob)) {
        result->SetData( (oaObserver_oaStdViaDef*) ((PyoaObserver_oaStdViaDefObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaStdViaDef Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaStdViaDef_FromoaObserver_oaStdViaDef(oaObserver_oaStdViaDef* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaStdViaDef_Type.tp_alloc(&PyoaObserver_oaStdViaDef_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaStdViaDefObject* self = (PyoaObserver_oaStdViaDefObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaStdViaDef::pyv_oaObserver_oaStdViaDef(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaStdViaDef(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaStdViaDef::pyv_oaObserver_oaStdViaDef(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaStdViaDef(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaStdViaDef::pyv_oaObserver_oaStdViaDef(const oaObserver_oaStdViaDef& p)
 : pyob(NULL),
   oaObserver_oaStdViaDef(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStdViaDef::onPostCreate(oaStdViaDef* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStdViaDef::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaStdViaDef_FromoaStdViaDef(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStdViaDef::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStdViaDef::onPostModify(oaStdViaDef* p1,oaViaDefModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStdViaDef::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaStdViaDef_FromoaStdViaDef(p1));
    PyTuple_SetItem(args,1,PyoaViaDefModTypeEnum_FromoaViaDefModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStdViaDef::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStdViaDef::onPreDestroy(oaStdViaDef* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStdViaDef::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaStdViaDef_FromoaStdViaDef(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStdViaDef::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStdViaDef::onPreModify(oaStdViaDef* p1,oaViaDefModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStdViaDef::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaStdViaDef_FromoaStdViaDef(p1));
    PyTuple_SetItem(args,1,PyoaViaDefModTypeEnum_FromoaViaDefModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStdViaDef::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaStdViaDef_doc[] = 
"Class: oaObserver_oaStdViaDef\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaStdViaDef(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaStdViaDef||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaStdViaDef\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaStdViaDef(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaStdViaDef||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaStdViaDef\n"
"  Paramegers: (oaObserver_oaStdViaDef)\n"
"    Calls: (const oaObserver_oaStdViaDef&)\n"
"    Signature: oaObserver_oaStdViaDef||cref-oaObserver_oaStdViaDef,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaStdViaDef_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaStdViaDef",
    sizeof(PyoaObserver_oaStdViaDefObject),
    0,
    (destructor)oaObserver_oaStdViaDef_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaStdViaDef_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaStdViaDef_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaStdViaDef_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaStdViaDef_oaViaDefModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaStdViaDef_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaStdViaDef_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaStdViaDef_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaStdViaDef\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaStdViaDef",
           (PyObject*)(&PyoaObserver_oaStdViaDef_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaStdViaDef\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaStdViaHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaStdViaHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaStdViaHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaStdViaHeaderObject* self = (PyoaObserver_oaStdViaHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaStdViaHeader(p1.Data());
            }
            else {
                pyv_oaObserver_oaStdViaHeader* p=new pyv_oaObserver_oaStdViaHeader(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaStdViaHeader(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaStdViaHeader* p=new pyv_oaObserver_oaStdViaHeader(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaStdViaHeader)
    {
        PyParamoaObserver_oaStdViaHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaStdViaHeader_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaStdViaHeader(p1.Data());
            }
            else {
                pyv_oaObserver_oaStdViaHeader* p=new pyv_oaObserver_oaStdViaHeader(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaStdViaHeader, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaStdViaHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaStdViaHeader_tp_dealloc(PyoaObserver_oaStdViaHeaderObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaStdViaHeader*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaStdViaHeader_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaStdViaHeader value;
    int convert_status=PyoaObserver_oaStdViaHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[47];
    sprintf(buffer,"<oaObserver_oaStdViaHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaStdViaHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaStdViaHeader v1;
    PyParamoaObserver_oaStdViaHeader v2;
    int convert_status1=PyoaObserver_oaStdViaHeader_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaStdViaHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaStdViaHeader_Convert(PyObject* ob,PyParamoaObserver_oaStdViaHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaStdViaHeader_Check(ob)) {
        result->SetData( (oaObserver_oaStdViaHeader*) ((PyoaObserver_oaStdViaHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaStdViaHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaStdViaHeader_FromoaObserver_oaStdViaHeader(oaObserver_oaStdViaHeader* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaStdViaHeader_Type.tp_alloc(&PyoaObserver_oaStdViaHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaStdViaHeaderObject* self = (PyoaObserver_oaStdViaHeaderObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaStdViaHeader::pyv_oaObserver_oaStdViaHeader(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaStdViaHeader(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaStdViaHeader::pyv_oaObserver_oaStdViaHeader(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaStdViaHeader(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaStdViaHeader::pyv_oaObserver_oaStdViaHeader(const oaObserver_oaStdViaHeader& p)
 : pyob(NULL),
   oaObserver_oaStdViaHeader(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStdViaHeader::onPostCreate(oaStdViaHeader* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStdViaHeader::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaStdViaHeader_FromoaStdViaHeader(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStdViaHeader::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStdViaHeader::onPostModify(oaStdViaHeader* p1,oaViaHeaderModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStdViaHeader::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaStdViaHeader_FromoaStdViaHeader(p1));
    PyTuple_SetItem(args,1,PyoaViaHeaderModTypeEnum_FromoaViaHeaderModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStdViaHeader::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStdViaHeader::onPreDestroy(oaStdViaHeader* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStdViaHeader::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaStdViaHeader_FromoaStdViaHeader(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStdViaHeader::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStdViaHeader::onPreModify(oaStdViaHeader* p1,oaViaHeaderModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStdViaHeader::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaStdViaHeader_FromoaStdViaHeader(p1));
    PyTuple_SetItem(args,1,PyoaViaHeaderModTypeEnum_FromoaViaHeaderModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStdViaHeader::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaStdViaHeader_doc[] = 
"Class: oaObserver_oaStdViaHeader\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaStdViaHeader(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaStdViaHeader||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaStdViaHeader\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaStdViaHeader(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaStdViaHeader||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaStdViaHeader\n"
"  Paramegers: (oaObserver_oaStdViaHeader)\n"
"    Calls: (const oaObserver_oaStdViaHeader&)\n"
"    Signature: oaObserver_oaStdViaHeader||cref-oaObserver_oaStdViaHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaStdViaHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaStdViaHeader",
    sizeof(PyoaObserver_oaStdViaHeaderObject),
    0,
    (destructor)oaObserver_oaStdViaHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaStdViaHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaStdViaHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaStdViaHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaStdViaHeader_oaViaHeaderModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaStdViaHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaStdViaHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaStdViaHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaStdViaHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaStdViaHeader",
           (PyObject*)(&PyoaObserver_oaStdViaHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaStdViaHeader\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaSteiner
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaSteiner_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaSteiner_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaSteinerObject* self = (PyoaObserver_oaSteinerObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaSteiner(p1.Data());
            }
            else {
                pyv_oaObserver_oaSteiner* p=new pyv_oaObserver_oaSteiner(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaSteiner(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaSteiner* p=new pyv_oaObserver_oaSteiner(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaSteiner)
    {
        PyParamoaObserver_oaSteiner p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaSteiner_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaSteiner(p1.Data());
            }
            else {
                pyv_oaObserver_oaSteiner* p=new pyv_oaObserver_oaSteiner(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaSteiner, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaSteiner)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaSteiner_tp_dealloc(PyoaObserver_oaSteinerObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaSteiner*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaSteiner_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaSteiner value;
    int convert_status=PyoaObserver_oaSteiner_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[42];
    sprintf(buffer,"<oaObserver_oaSteiner::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaSteiner_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaSteiner v1;
    PyParamoaObserver_oaSteiner v2;
    int convert_status1=PyoaObserver_oaSteiner_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaSteiner_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaSteiner_Convert(PyObject* ob,PyParamoaObserver_oaSteiner* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaSteiner_Check(ob)) {
        result->SetData( (oaObserver_oaSteiner*) ((PyoaObserver_oaSteinerObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaSteiner Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaSteiner_FromoaObserver_oaSteiner(oaObserver_oaSteiner* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaSteiner_Type.tp_alloc(&PyoaObserver_oaSteiner_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaSteinerObject* self = (PyoaObserver_oaSteinerObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaSteiner::pyv_oaObserver_oaSteiner(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaSteiner(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaSteiner::pyv_oaObserver_oaSteiner(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaSteiner(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaSteiner::pyv_oaObserver_oaSteiner(const oaObserver_oaSteiner& p)
 : pyob(NULL),
   oaObserver_oaSteiner(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSteiner::onPostCreate(oaSteiner* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSteiner::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaSteiner_FromoaSteiner(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSteiner::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSteiner::onPostModify(oaSteiner* p1,oaSteinerModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSteiner::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaSteiner_FromoaSteiner(p1));
    PyTuple_SetItem(args,1,PyoaSteinerModTypeEnum_FromoaSteinerModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSteiner::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSteiner::onPreDestroy(oaSteiner* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSteiner::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaSteiner_FromoaSteiner(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSteiner::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSteiner::onPreModify(oaSteiner* p1,oaSteinerModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSteiner::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaSteiner_FromoaSteiner(p1));
    PyTuple_SetItem(args,1,PyoaSteinerModTypeEnum_FromoaSteinerModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSteiner::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaSteiner_doc[] = 
"Class: oaObserver_oaSteiner\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaSteiner(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaSteiner||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaSteiner\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaSteiner(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaSteiner||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaSteiner\n"
"  Paramegers: (oaObserver_oaSteiner)\n"
"    Calls: (const oaObserver_oaSteiner&)\n"
"    Signature: oaObserver_oaSteiner||cref-oaObserver_oaSteiner,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaSteiner_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaSteiner",
    sizeof(PyoaObserver_oaSteinerObject),
    0,
    (destructor)oaObserver_oaSteiner_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaSteiner_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaSteiner_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaSteiner_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaSteiner_oaSteinerModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaSteiner_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaSteiner_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaSteiner_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaSteiner\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaSteiner",
           (PyObject*)(&PyoaObserver_oaSteiner_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaSteiner\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaStepperMap
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaStepperMap_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaStepperMap_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaStepperMapObject* self = (PyoaObserver_oaStepperMapObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaStepperMap(p1.Data());
            }
            else {
                pyv_oaObserver_oaStepperMap* p=new pyv_oaObserver_oaStepperMap(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaStepperMap(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaStepperMap* p=new pyv_oaObserver_oaStepperMap(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaStepperMap)
    {
        PyParamoaObserver_oaStepperMap p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaStepperMap_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaStepperMap(p1.Data());
            }
            else {
                pyv_oaObserver_oaStepperMap* p=new pyv_oaObserver_oaStepperMap(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaStepperMap, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaStepperMap)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaStepperMap_tp_dealloc(PyoaObserver_oaStepperMapObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaStepperMap*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaStepperMap_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaStepperMap value;
    int convert_status=PyoaObserver_oaStepperMap_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaObserver_oaStepperMap::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaStepperMap_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaStepperMap v1;
    PyParamoaObserver_oaStepperMap v2;
    int convert_status1=PyoaObserver_oaStepperMap_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaStepperMap_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaStepperMap_Convert(PyObject* ob,PyParamoaObserver_oaStepperMap* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaStepperMap_Check(ob)) {
        result->SetData( (oaObserver_oaStepperMap*) ((PyoaObserver_oaStepperMapObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaStepperMap Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaStepperMap_FromoaObserver_oaStepperMap(oaObserver_oaStepperMap* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaStepperMap_Type.tp_alloc(&PyoaObserver_oaStepperMap_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaStepperMapObject* self = (PyoaObserver_oaStepperMapObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaStepperMap::pyv_oaObserver_oaStepperMap(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaStepperMap(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaStepperMap::pyv_oaObserver_oaStepperMap(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaStepperMap(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaStepperMap::pyv_oaObserver_oaStepperMap(const oaObserver_oaStepperMap& p)
 : pyob(NULL),
   oaObserver_oaStepperMap(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStepperMap::onPostCreate(oaStepperMap* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStepperMap::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaStepperMap_FromoaStepperMap(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStepperMap::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStepperMap::onPostModify(oaStepperMap* p1,oaStepperMapModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStepperMap::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaStepperMap_FromoaStepperMap(p1));
    PyTuple_SetItem(args,1,PyoaStepperMapModTypeEnum_FromoaStepperMapModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStepperMap::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStepperMap::onPreDestroy(oaStepperMap* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStepperMap::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaStepperMap_FromoaStepperMap(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStepperMap::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStepperMap::onPreModify(oaStepperMap* p1,oaStepperMapModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStepperMap::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaStepperMap_FromoaStepperMap(p1));
    PyTuple_SetItem(args,1,PyoaStepperMapModTypeEnum_FromoaStepperMapModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStepperMap::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaStepperMap_doc[] = 
"Class: oaObserver_oaStepperMap\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaStepperMap(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaStepperMap||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaStepperMap\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaStepperMap(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaStepperMap||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaStepperMap\n"
"  Paramegers: (oaObserver_oaStepperMap)\n"
"    Calls: (const oaObserver_oaStepperMap&)\n"
"    Signature: oaObserver_oaStepperMap||cref-oaObserver_oaStepperMap,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaStepperMap_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaStepperMap",
    sizeof(PyoaObserver_oaStepperMapObject),
    0,
    (destructor)oaObserver_oaStepperMap_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaStepperMap_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaStepperMap_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaStepperMap_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaStepperMap_oaStepperMapModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaStepperMap_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaStepperMap_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaStepperMap_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaStepperMap\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaStepperMap",
           (PyObject*)(&PyoaObserver_oaStepperMap_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaStepperMap\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaStringProp
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaStringProp_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaStringProp_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaStringPropObject* self = (PyoaObserver_oaStringPropObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaStringProp(p1.Data());
            }
            else {
                pyv_oaObserver_oaStringProp* p=new pyv_oaObserver_oaStringProp(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaStringProp(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaStringProp* p=new pyv_oaObserver_oaStringProp(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaStringProp)
    {
        PyParamoaObserver_oaStringProp p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaStringProp_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaStringProp(p1.Data());
            }
            else {
                pyv_oaObserver_oaStringProp* p=new pyv_oaObserver_oaStringProp(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaStringProp, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaStringProp)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaStringProp_tp_dealloc(PyoaObserver_oaStringPropObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaStringProp*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaStringProp_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaStringProp value;
    int convert_status=PyoaObserver_oaStringProp_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaObserver_oaStringProp::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaStringProp_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaStringProp v1;
    PyParamoaObserver_oaStringProp v2;
    int convert_status1=PyoaObserver_oaStringProp_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaStringProp_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaStringProp_Convert(PyObject* ob,PyParamoaObserver_oaStringProp* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaStringProp_Check(ob)) {
        result->SetData( (oaObserver_oaStringProp*) ((PyoaObserver_oaStringPropObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaStringProp Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaStringProp_FromoaObserver_oaStringProp(oaObserver_oaStringProp* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaStringProp_Type.tp_alloc(&PyoaObserver_oaStringProp_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaStringPropObject* self = (PyoaObserver_oaStringPropObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaStringProp::pyv_oaObserver_oaStringProp(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaStringProp(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaStringProp::pyv_oaObserver_oaStringProp(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaStringProp(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaStringProp::pyv_oaObserver_oaStringProp(const oaObserver_oaStringProp& p)
 : pyob(NULL),
   oaObserver_oaStringProp(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStringProp::onPostCreate(oaStringProp* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStringProp::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaStringProp_FromoaStringProp(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStringProp::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStringProp::onPostModify(oaStringProp* p1,oaPropModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStringProp::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaStringProp_FromoaStringProp(p1));
    PyTuple_SetItem(args,1,PyoaPropModTypeEnum_FromoaPropModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStringProp::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStringProp::onPreDestroy(oaStringProp* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStringProp::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaStringProp_FromoaStringProp(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStringProp::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaStringProp::onPreModify(oaStringProp* p1,oaPropModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaStringProp::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaStringProp_FromoaStringProp(p1));
    PyTuple_SetItem(args,1,PyoaPropModTypeEnum_FromoaPropModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaStringProp::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaStringProp_doc[] = 
"Class: oaObserver_oaStringProp\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaStringProp(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaStringProp||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaStringProp\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaStringProp(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaStringProp||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaStringProp\n"
"  Paramegers: (oaObserver_oaStringProp)\n"
"    Calls: (const oaObserver_oaStringProp&)\n"
"    Signature: oaObserver_oaStringProp||cref-oaObserver_oaStringProp,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaStringProp_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaStringProp",
    sizeof(PyoaObserver_oaStringPropObject),
    0,
    (destructor)oaObserver_oaStringProp_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaStringProp_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaStringProp_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaStringProp_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaStringProp_oaPropModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaStringProp_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaStringProp_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaStringProp_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaStringProp\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaStringProp",
           (PyObject*)(&PyoaObserver_oaStringProp_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaStringProp\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaSubNetwork
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaSubNetwork_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaSubNetwork_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaSubNetworkObject* self = (PyoaObserver_oaSubNetworkObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaSubNetwork(p1.Data());
            }
            else {
                pyv_oaObserver_oaSubNetwork* p=new pyv_oaObserver_oaSubNetwork(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaSubNetwork(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaSubNetwork* p=new pyv_oaObserver_oaSubNetwork(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaSubNetwork)
    {
        PyParamoaObserver_oaSubNetwork p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaSubNetwork_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaSubNetwork(p1.Data());
            }
            else {
                pyv_oaObserver_oaSubNetwork* p=new pyv_oaObserver_oaSubNetwork(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaSubNetwork, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaSubNetwork)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaSubNetwork_tp_dealloc(PyoaObserver_oaSubNetworkObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaSubNetwork*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaSubNetwork_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaSubNetwork value;
    int convert_status=PyoaObserver_oaSubNetwork_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaObserver_oaSubNetwork::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaSubNetwork_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaSubNetwork v1;
    PyParamoaObserver_oaSubNetwork v2;
    int convert_status1=PyoaObserver_oaSubNetwork_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaSubNetwork_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaSubNetwork_Convert(PyObject* ob,PyParamoaObserver_oaSubNetwork* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaSubNetwork_Check(ob)) {
        result->SetData( (oaObserver_oaSubNetwork*) ((PyoaObserver_oaSubNetworkObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaSubNetwork Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaSubNetwork_FromoaObserver_oaSubNetwork(oaObserver_oaSubNetwork* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaSubNetwork_Type.tp_alloc(&PyoaObserver_oaSubNetwork_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaSubNetworkObject* self = (PyoaObserver_oaSubNetworkObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaSubNetwork::pyv_oaObserver_oaSubNetwork(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaSubNetwork(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaSubNetwork::pyv_oaObserver_oaSubNetwork(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaSubNetwork(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaSubNetwork::pyv_oaObserver_oaSubNetwork(const oaObserver_oaSubNetwork& p)
 : pyob(NULL),
   oaObserver_oaSubNetwork(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSubNetwork::onPostCreate(oaSubNetwork* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSubNetwork::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaSubNetwork_FromoaSubNetwork(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSubNetwork::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSubNetwork::onPostModify(oaSubNetwork* p1,oaSubNetworkModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSubNetwork::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaSubNetwork_FromoaSubNetwork(p1));
    PyTuple_SetItem(args,1,PyoaSubNetworkModTypeEnum_FromoaSubNetworkModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSubNetwork::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSubNetwork::onPreDestroy(oaSubNetwork* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSubNetwork::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaSubNetwork_FromoaSubNetwork(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSubNetwork::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaSubNetwork::onPreModify(oaSubNetwork* p1,oaSubNetworkModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaSubNetwork::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaSubNetwork_FromoaSubNetwork(p1));
    PyTuple_SetItem(args,1,PyoaSubNetworkModTypeEnum_FromoaSubNetworkModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaSubNetwork::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaSubNetwork_doc[] = 
"Class: oaObserver_oaSubNetwork\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaSubNetwork(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaSubNetwork||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaSubNetwork\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaSubNetwork(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaSubNetwork||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaSubNetwork\n"
"  Paramegers: (oaObserver_oaSubNetwork)\n"
"    Calls: (const oaObserver_oaSubNetwork&)\n"
"    Signature: oaObserver_oaSubNetwork||cref-oaObserver_oaSubNetwork,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaSubNetwork_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaSubNetwork",
    sizeof(PyoaObserver_oaSubNetworkObject),
    0,
    (destructor)oaObserver_oaSubNetwork_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaSubNetwork_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaSubNetwork_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaSubNetwork_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaSubNetwork_oaSubNetworkModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaSubNetwork_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaSubNetwork_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaSubNetwork_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaSubNetwork\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaSubNetwork",
           (PyObject*)(&PyoaObserver_oaSubNetwork_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaSubNetwork\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaTech
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaTech_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaTech_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaTechObject* self = (PyoaObserver_oaTechObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaTech(p1.Data());
            }
            else {
                pyv_oaObserver_oaTech* p=new pyv_oaObserver_oaTech(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaTech, Choices are:\n"
        "    (oaUInt4)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaTech_tp_dealloc(PyoaObserver_oaTechObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaTech*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaTech_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaTech value;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[39];
    sprintf(buffer,"<oaObserver_oaTech::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaTech_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaTech v1;
    PyParamoaObserver_oaTech v2;
    int convert_status1=PyoaObserver_oaTech_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaTech_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaTech_Convert(PyObject* ob,PyParamoaObserver_oaTech* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaTech_Check(ob)) {
        result->SetData( (oaObserver_oaTech*) ((PyoaObserver_oaTechObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaTech Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaTech_FromoaObserver_oaTech(oaObserver_oaTech* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaTech_Type.tp_alloc(&PyoaObserver_oaTech_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaTechObject* self = (PyoaObserver_oaTechObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaTech::pyv_oaObserver_oaTech(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaTech(p1)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onClearanceMeasureConflict(oaTechArray p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onClearanceMeasureConflict");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onClearanceMeasureConflict was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTechArray_FromoaTechArray(&p1,1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onClearanceMeasureConflict had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onConflict(oaTech* p1,oaTechConflictTypeEnum p2,oaObjectArray p3)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onConflict");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onConflict was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(3);
    PyTuple_SetItem(args,0,PyoaTech_FromoaTech(p1));
    PyTuple_SetItem(args,1,PyoaTechConflictTypeEnum_FromoaTechConflictTypeEnum(p2));
    PyTuple_SetItem(args,2,PyoaObjectArray_FromoaObjectArray(&p3,1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onConflict had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onCreate(oaTech* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTech_FromoaTech(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onDBUPerUUConflict(oaTechArray p1,oaViewType* p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onDBUPerUUConflict");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onDBUPerUUConflict was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaTechArray_FromoaTechArray(&p1,1));
    PyTuple_SetItem(args,1,PyoaViewType_FromoaViewType(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onDBUPerUUConflict had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onDefaultManufacturingGridConflict(oaTechArray p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onDefaultManufacturingGridConflict");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onDefaultManufacturingGridConflict was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTechArray_FromoaTechArray(&p1,1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onDefaultManufacturingGridConflict had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onFirstOpen(oaTech* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onFirstOpen");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onFirstOpen was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTech_FromoaTech(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onFirstOpen had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onGateGroundedConflict(oaTechArray p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onGateGroundedConflict");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onGateGroundedConflict was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTechArray_FromoaTechArray(&p1,1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onGateGroundedConflict had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onPostAttach(oaLib* p1,const oaScalarName& p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostAttach");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPostAttach was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaLib_FromoaLib(p1));
    PyTuple_SetItem(args,1,PyoaScalarName_FromoaScalarName((oaScalarName*)(&p2),1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPostAttach had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onPostDetach(oaLib* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostDetach");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPostDetach was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaLib_FromoaLib(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPostDetach had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onPostModify(oaTech* p1,oaTechModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaTech_FromoaTech(p1));
    PyTuple_SetItem(args,1,PyoaTechModTypeEnum_FromoaTechModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onPostOpenRefs(oaTech* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostOpenRefs");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPostOpenRefs was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTech_FromoaTech(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPostOpenRefs had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onPostReopen(oaTech* p1,oaChar p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostReopen");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPostReopen was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaTech_FromoaTech(p1));
    PyTuple_SetItem(args,1,PyoaChar_FromoaChar(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPostReopen had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onPostSave(oaTech* p1,oaBoolean p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostSave");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPostSave was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaTech_FromoaTech(p1));
    PyTuple_SetItem(args,1,PyoaBoolean_FromoaBoolean(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPostSave had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onPostSaveAs(oaTech* p1,oaBoolean p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostSaveAs");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPostSaveAs was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaTech_FromoaTech(p1));
    PyTuple_SetItem(args,1,PyoaBoolean_FromoaBoolean(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPostSaveAs had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onPreAttach(oaLib* p1,const oaScalarName& p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreAttach");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPreAttach was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaLib_FromoaLib(p1));
    PyTuple_SetItem(args,1,PyoaScalarName_FromoaScalarName((oaScalarName*)(&p2),1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPreAttach had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onPreDetach(oaLib* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDetach");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPreDetach was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaLib_FromoaLib(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPreDetach had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onPreModify(oaTech* p1,oaTechModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaTech_FromoaTech(p1));
    PyTuple_SetItem(args,1,PyoaTechModTypeEnum_FromoaTechModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPreModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onPreOpenRefs(oaTech* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreOpenRefs");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPreOpenRefs was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTech_FromoaTech(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPreOpenRefs had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onPreReopen(oaTech* p1,oaChar p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreReopen");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPreReopen was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaTech_FromoaTech(p1));
    PyTuple_SetItem(args,1,PyoaChar_FromoaChar(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPreReopen had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onPreSave(oaTech* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreSave");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPreSave was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTech_FromoaTech(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPreSave had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onPreSaveAs(oaTech* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreSaveAs");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPreSaveAs was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTech_FromoaTech(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPreSaveAs had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onPurge(oaTech* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPurge");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPurge was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTech_FromoaTech(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onPurge had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onTruncate(oaTech* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onTruncate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onTruncate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTech_FromoaTech(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onTruncate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onUnboundRef(oaTech* p1,oaTechHeader* p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onUnboundRef");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onUnboundRef was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaTech_FromoaTech(p1));
    PyTuple_SetItem(args,1,PyoaTechHeader_FromoaTechHeader(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onUnboundRef had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTech::onUserUnitsConflict(oaTechArray p1,oaViewType* p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onUserUnitsConflict");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onUserUnitsConflict was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaTechArray_FromoaTechArray(&p1,1));
    PyTuple_SetItem(args,1,PyoaViewType_FromoaViewType(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTech::onUserUnitsConflict had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
// FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaTech_onClearanceMeasureConflict_doc[] = 
"Class: oaObserver_oaTech, Function: onClearanceMeasureConflict\n"
"  Paramegers: (oaTechArray)\n"
"    Calls: virtual void onClearanceMeasureConflict(oaTechArray conflictingTechs)\n"
"    Signature: onClearanceMeasureConflict|void-void|simple-oaTechArray,\n"
"    oaTechObserver::onClearanceMeasureConflict\n"
"    This function is called when the ClearanceMeasure attribute has conflicting (non-equal) values in a graph of technology databases.\n"
"    This can occur when a tech database that is part of a graph of referenced techs is edited out of context and then reintroduced into the graph.\n"
"    The application's derived class should implement this function to receive notification when a tech database has an ClearanceMeasure attribute whose value conflicts with another ClearanceMeasure attribute in a different tech in the graph of tech databases.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    conflictingTechs\n"
"    Array of technology databases in which the attributes conflict. The first element in the array is the most derived tech in the graph.\n"
;

static PyObject*
oaObserver_oaTech_onClearanceMeasureConflict(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTechArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTechArray_Convert,&p1)) {
        data.DataCall()->oaObserver_oaTech::onClearanceMeasureConflict(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onConflict_doc[] = 
"Class: oaObserver_oaTech, Function: onConflict\n"
"  Paramegers: (oaTech,oaTechConflictTypeEnum,oaObjectArray)\n"
"    Calls: virtual void onConflict(oaTech* mostDerivedTech,oaTechConflictTypeEnum conflictType,oaObjectArray conflictingObjs)\n"
"    Signature: onConflict|void-void|ptr-oaTech,simple-oaTechConflictTypeEnum,simple-oaObjectArray,\n"
"    oaObserver_oaTech_::onConflict\n"
"    This function is called when there are conflicting technology objects in a graph of technology databases. This can occur when a tech database that is part of a graph of referenced techs is edited out of context and then reintroduced into the graph through reopening the graph.\n"
"    The application's derived class should implement this function to receive notification when there is a conflicting technology object in the graph of tech databases.\n"
"    Note: It is the application's responsibility to resolve the observed conflict. The observed conflict is resolved when all except one object in the conflictingObjs array are deleted.\n"
"    Refer to Technology Objects in the Using Technology Databases section of the Programmers Guide for more information.\n"
"    mostDerivedTech\n"
"    The tech that is at the top of the tech graph with the observed conflicts\n"
"    conflictType\n"
"    The type of conflict\n"
"    conflictingObjs\n"
"    An array of objects in a group of techs that conflict with each other\n"
;

static PyObject*
oaObserver_oaTech_onConflict(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTech p1;
    PyParamoaTechConflictTypeEnum p2;
    PyParamoaObjectArray p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaTechConflictTypeEnum_Convert,&p2,
          &PyoaObjectArray_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onConflict(p1.Data(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onCreate_doc[] = 
"Class: oaObserver_oaTech, Function: onCreate\n"
"  Paramegers: (oaTech)\n"
"    Calls: virtual void onCreate(oaTech* tech)\n"
"    Signature: onCreate|void-void|ptr-oaTech,\n"
"    This function is called after an oaTech object is created. The application's derived observer class should implement this function to receive notification when an oaTech object is created.\n"
"    tech\n"
"    pointer to the created oaTech object\n"
;

static PyObject*
oaObserver_oaTech_onCreate(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onCreate(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onDBUPerUUConflict_doc[] = 
"Class: oaObserver_oaTech, Function: onDBUPerUUConflict\n"
"  Paramegers: (oaTechArray,oaViewType)\n"
"    Calls: virtual void onDBUPerUUConflict(oaTechArray conflictingTechs,oaViewType* viewType)\n"
"    Signature: onDBUPerUUConflict|void-void|simple-oaTechArray,ptr-oaViewType,\n"
"    oaTechObserver::onDBUPerUUConflict\n"
"    This function is called when the DBUPerUU attribute has conflicting (non-equal) values in a graph of technology databases.\n"
"    This can occur when a tech database that is part of a graph of referenced techs is edited out of context and then reintroduced into the graph.\n"
"    The application's derived class should implement this function to receive notification when a tech database has a DBUPerUU attribute whose value conflicts with another DBUPerUU attribute in a different tech in the graph of tech databases.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    conflictingTechs\n"
"    Array of technology databases in which the attributes conflict. The first element in the array is the most derived tech in the graph.\n"
"    viewType\n"
"    Pointer to an oaViewType associated with the attribute.\n"
;

static PyObject*
oaObserver_oaTech_onDBUPerUUConflict(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTechArray p1;
    PyParamoaViewType p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechArray_Convert,&p1,
          &PyoaViewType_Convert,&p2)) {
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        data.DataCall()->oaObserver_oaTech::onDBUPerUUConflict(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onDefaultManufacturingGridConflict_doc[] = 
"Class: oaObserver_oaTech, Function: onDefaultManufacturingGridConflict\n"
"  Paramegers: (oaTechArray)\n"
"    Calls: virtual void onDefaultManufacturingGridConflict(oaTechArray conflictingTechs)\n"
"    Signature: onDefaultManufacturingGridConflict|void-void|simple-oaTechArray,\n"
"    oaTechObserver::onDefaultManufacturingGridConflict\n"
"    This function is called when the DefaultManufacturingGrid attribute has conflicting (non-equal) values in a graph of technology databases.\n"
"    This can occur when a tech database that is part of a graph of referenced techs is edited out of context and then reintroduced into the graph.\n"
"    The application's derived class should implement this function to receive notification when a tech database has a DefaultManufacturingGrid attribute whose value conflicts with another DefaultManufacturingGrid attribute in a different tech in the graph of tech databases.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    conflictingTechs\n"
"    Array of technology databases in which the attributes conflict. The first element in the array is the most derived tech in the graph.\n"
;

static PyObject*
oaObserver_oaTech_onDefaultManufacturingGridConflict(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTechArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTechArray_Convert,&p1)) {
        data.DataCall()->oaObserver_oaTech::onDefaultManufacturingGridConflict(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onFirstOpen_doc[] = 
"Class: oaObserver_oaTech, Function: onFirstOpen\n"
"  Paramegers: (oaTech)\n"
"    Calls: virtual void onFirstOpen(oaTech* tech)\n"
"    Signature: onFirstOpen|void-void|ptr-oaTech,\n"
"    This function is called when an oaTech object is first opened. The application's derived class should implement this function to receive notification when an oaTech object has been opened.\n"
"    tech\n"
"    A pointer to the newly-opened oaTech object\n"
;

static PyObject*
oaObserver_oaTech_onFirstOpen(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onFirstOpen(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onGateGroundedConflict_doc[] = 
"Class: oaObserver_oaTech, Function: onGateGroundedConflict\n"
"  Paramegers: (oaTechArray)\n"
"    Calls: virtual void onGateGroundedConflict(oaTechArray conflictingTechs)\n"
"    Signature: onGateGroundedConflict|void-void|simple-oaTechArray,\n"
"    oaTechObserver::onGateGroundedConflict\n"
"    This function is called when the GateGrounded attribute has conflicting (non-equal) values in a graph of technology databases.\n"
"    This can occur when a tech database that is part of a graph of referenced techs is edited out of context and then reintroduced into the graph.\n"
"    The application's derived class should implement this function to receive notification when a tech database has a GateGrounded attribute whose value conflicts with another GateGrounded attribute in a different tech in the graph of tech databases.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    conflictingTechs\n"
"    Array of technology databases in which the attributes conflict. The first element in the array is the most derived tech in the graph.\n"
;

static PyObject*
oaObserver_oaTech_onGateGroundedConflict(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTechArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTechArray_Convert,&p1)) {
        data.DataCall()->oaObserver_oaTech::onGateGroundedConflict(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onPostAttach_doc[] = 
"Class: oaObserver_oaTech, Function: onPostAttach\n"
"  Paramegers: (oaLib,oaScalarName)\n"
"    Calls: virtual void onPostAttach(oaLib* lib,const oaScalarName& attachLibName)\n"
"    Signature: onPostAttach|void-void|ptr-oaLib,cref-oaScalarName,\n"
"    onPostAttach\n"
"    This function is called after before a technology library attachment is made using oaTech::attach .\n"
"    lib\n"
"    Pointer to the library being attached.\n"
"    attachLibName\n"
"    Name of the library to attach to.\n"
"    Todo\n"
"    Shelly: please fill in description of function and parameters\n"
;

static PyObject*
oaObserver_oaTech_onPostAttach(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaLib p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaLib_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onPostAttach(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onPostDetach_doc[] = 
"Class: oaObserver_oaTech, Function: onPostDetach\n"
"  Paramegers: (oaLib)\n"
"    Calls: virtual void onPostDetach(oaLib* lib)\n"
"    Signature: onPostDetach|void-void|ptr-oaLib,\n"
"    onPostDetach\n"
"    This function is called just after a library attachment is removed using oaTech::detach .\n"
"    lib\n"
"    Pointer to the library being detached.\n"
"    Todo\n"
"    Shelly: please fill in description of function and parameters\n"
;

static PyObject*
oaObserver_oaTech_onPostDetach(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaLib p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaLib_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onPostDetach(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onPostModify_doc[] = 
"Class: oaObserver_oaTech, Function: onPostModify\n"
"  Paramegers: (oaTech,oaTechModTypeEnum)\n"
"    Calls: virtual void onPostModify(oaTech* tech,oaTechModTypeEnum modType)\n"
"    Signature: onPostModify|void-void|ptr-oaTech,simple-oaTechModTypeEnum,\n"
"    This function is called after an oaTech object has been modified. The application's derived class should implement this function to receive notification when an oaTech object has been modified.\n"
"    tech\n"
"    A pointer to the modified oaTech object\n"
"    modType\n"
"    The type of modification that was made\n"
;

static PyObject*
oaObserver_oaTech_onPostModify(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTech p1;
    PyParamoaTechModTypeEnum p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaTechModTypeEnum_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onPostModify(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onPostOpenRefs_doc[] = 
"Class: oaObserver_oaTech, Function: onPostOpenRefs\n"
"  Paramegers: (oaTech)\n"
"    Calls: virtual void onPostOpenRefs(oaTech* tech)\n"
"    Signature: onPostOpenRefs|void-void|ptr-oaTech,\n"
"    onPostOpenRefs\n"
"    This function is called after references are bound for an incremental technology database. These notifications occur after a technology database that has references is opened, and also after oaTech::setRefs() is performed on a technology database.\n"
"    The application's derived class should implement this function to receive notification after the binding and opening of referenced databases.\n"
"    Note: There is a notion here of a recursive descent. For example, when you have a technology database graph, A->B->C, if you open A, and B and C are not opened, you get the following notifications:\n"
"    onPreOpenRefs(A)\n"
"    onPreOpenRefs(B)\n"
"    onPostOpenRefs(B)\n"
"    onPostOpenRefs(A)\n"
"    tech\n"
"    Pointer to the oaTech object that has references.\n"
;

static PyObject*
oaObserver_oaTech_onPostOpenRefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onPostOpenRefs(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onPostReopen_doc[] = 
"Class: oaObserver_oaTech, Function: onPostReopen\n"
"  Paramegers: (oaTech,oaChar)\n"
"    Calls: virtual void onPostReopen(oaTech* tech,oaChar oldMode)\n"
"    Signature: onPostReopen|void-void|ptr-oaTech,simple-oaChar,\n"
"    This function is called just after an oaTech object is reopened using a new access mode. The application's derived class should implement this function to receive notification when an oaTech object has been reopened in a new access mode.\n"
"    tech\n"
"    A pointer to the oaTech with the mode change\n"
"    oldMode\n"
"    The mode with which the oaTech was previously opened\n"
;

static PyObject*
oaObserver_oaTech_onPostReopen(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTech p1;
    PyParamoaChar p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaChar_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onPostReopen(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onPostSave_doc[] = 
"Class: oaObserver_oaTech, Function: onPostSave\n"
"  Paramegers: (oaTech,oaBoolean)\n"
"    Calls: virtual void onPostSave(oaTech* tech,oaBoolean succeeded)\n"
"    Signature: onPostSave|void-void|ptr-oaTech,simple-oaBoolean,\n"
"    This function is called just after an attempt to save an oaTech object to disk. The application's derived class should implement this function to receive notification when a save on an oaTech has been attempted.\n"
"    tech\n"
"    a pointer to the saved oaTech\n"
"    succeeded\n"
"    a boolean that indicates whether the save was successful\n"
;

static PyObject*
oaObserver_oaTech_onPostSave(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTech p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onPostSave(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onPostSaveAs_doc[] = 
"Class: oaObserver_oaTech, Function: onPostSaveAs\n"
"  Paramegers: (oaTech,oaBoolean)\n"
"    Calls: virtual void onPostSaveAs(oaTech* tech,oaBoolean succeeded)\n"
"    Signature: onPostSaveAs|void-void|ptr-oaTech,simple-oaBoolean,\n"
"    This function is called after an attempt has been made to save an oaTech to disk in a user-specified library (through an oaTech::saveAs call). The application's derived class should implement this function to receive notification when an attempt has been made to save an oaTech object to disk in a user-specified library.\n"
"    tech\n"
"    a pointer to the oaTech on which the saveAs() call was made\n"
"    succeeded\n"
"    a oaBoolean that indicates whether the save was successful\n"
;

static PyObject*
oaObserver_oaTech_onPostSaveAs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTech p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onPostSaveAs(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onPreAttach_doc[] = 
"Class: oaObserver_oaTech, Function: onPreAttach\n"
"  Paramegers: (oaLib,oaScalarName)\n"
"    Calls: virtual void onPreAttach(oaLib* lib,const oaScalarName& attachLibName)\n"
"    Signature: onPreAttach|void-void|ptr-oaLib,cref-oaScalarName,\n"
"    onPreAttach\n"
"    This function is called just before a technology library attachment is made using oaTech::attach .\n"
"    lib\n"
"    Pointer to the library being attached.\n"
"    attachLibName\n"
"    Name of the library to attach to.\n"
"    Todo\n"
"    Shelly: please fill in description of function and parameters\n"
;

static PyObject*
oaObserver_oaTech_onPreAttach(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaLib p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaLib_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onPreAttach(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onPreDetach_doc[] = 
"Class: oaObserver_oaTech, Function: onPreDetach\n"
"  Paramegers: (oaLib)\n"
"    Calls: virtual void onPreDetach(oaLib* lib)\n"
"    Signature: onPreDetach|void-void|ptr-oaLib,\n"
"    onPreDetach\n"
"    This function is called just before a library attachment is removed using oaTech::detach .\n"
"    lib\n"
"    Pointer to the library being detached.\n"
"    Todo\n"
"    Shelly: please fill in description of function and parameter\n"
;

static PyObject*
oaObserver_oaTech_onPreDetach(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaLib p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaLib_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onPreDetach(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onPreModify_doc[] = 
"Class: oaObserver_oaTech, Function: onPreModify\n"
"  Paramegers: (oaTech,oaTechModTypeEnum)\n"
"    Calls: virtual void onPreModify(oaTech* tech,oaTechModTypeEnum modType)\n"
"    Signature: onPreModify|void-void|ptr-oaTech,simple-oaTechModTypeEnum,\n"
"    This function is called before an oaTech object is modified. The application's derived class should implement this function to receive notification when an oaTech object is about to be modified.\n"
"    tech\n"
"    A pointer to the oaTech object to be modified\n"
"    modType\n"
"    The type of modification to be made\n"
;

static PyObject*
oaObserver_oaTech_onPreModify(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTech p1;
    PyParamoaTechModTypeEnum p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaTechModTypeEnum_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onPreModify(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onPreOpenRefs_doc[] = 
"Class: oaObserver_oaTech, Function: onPreOpenRefs\n"
"  Paramegers: (oaTech)\n"
"    Calls: virtual void onPreOpenRefs(oaTech* tech)\n"
"    Signature: onPreOpenRefs|void-void|ptr-oaTech,\n"
"    onPreOpenRefs\n"
"    This function is called before references are bound for an incremental technology database. These notifications occur when a technology database that has references is opened, and also when oaTech::setRefs() is performed on a technology database. The reference is opened and the referenced databases are bound. Referenced databases may themselves be opened in order to complete the binding.\n"
"    The application's derived class should implement this function to receive notification prior to the binding and opening of referenced databases.\n"
"    Note: There is a notion here of a recursive descent. For example, when you have a technology database graph, A->B->C, if you open A, and B and C are not opened, you get the following notifications:\n"
"    onPreOpenRefs(A)\n"
"    onPreOpenRefs(B)\n"
"    onPostOpenRefs(B)\n"
"    onPostOpenRefs(A)\n"
"    tech\n"
"    Pointer to the oaTech object that has references.\n"
;

static PyObject*
oaObserver_oaTech_onPreOpenRefs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onPreOpenRefs(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onPreReopen_doc[] = 
"Class: oaObserver_oaTech, Function: onPreReopen\n"
"  Paramegers: (oaTech,oaChar)\n"
"    Calls: virtual void onPreReopen(oaTech* tech,oaChar newMode)\n"
"    Signature: onPreReopen|void-void|ptr-oaTech,simple-oaChar,\n"
"    This function is called before an oaTech object is reopened using a different access mode. The application's derived class should implement this function to receive notification when an oaTech object is about to be reopened.\n"
"    tech\n"
"    A pointer to the oaTech about to be reopened\n"
"    newMode\n"
"    The new mode in which the oaTech will be reopened\n"
;

static PyObject*
oaObserver_oaTech_onPreReopen(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTech p1;
    PyParamoaChar p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaChar_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onPreReopen(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onPreSave_doc[] = 
"Class: oaObserver_oaTech, Function: onPreSave\n"
"  Paramegers: (oaTech)\n"
"    Calls: virtual void onPreSave(oaTech* tech)\n"
"    Signature: onPreSave|void-void|ptr-oaTech,\n"
"    This function is called just before an oaTech object is saved to disk. The application's derived class should implement this function to receive notification when an oaTech object is about to be saved.\n"
"    tech\n"
"    A pointer to the design to be saved\n"
;

static PyObject*
oaObserver_oaTech_onPreSave(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onPreSave(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onPreSaveAs_doc[] = 
"Class: oaObserver_oaTech, Function: onPreSaveAs\n"
"  Paramegers: (oaTech)\n"
"    Calls: virtual void onPreSaveAs(oaTech* tech)\n"
"    Signature: onPreSaveAs|void-void|ptr-oaTech,\n"
"    This function is called just before a design is saved to disk in a user-specified library (through an oaTech::saveAs call). The application's derived class should implement this function to receive notification when an oaTech object is about to be saved in a user-specified library.\n"
"    tech\n"
"    A pointer to the oaTech about to be saved\n"
;

static PyObject*
oaObserver_oaTech_onPreSaveAs(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onPreSaveAs(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onPurge_doc[] = 
"Class: oaObserver_oaTech, Function: onPurge\n"
"  Paramegers: (oaTech)\n"
"    Calls: virtual void onPurge(oaTech* tech)\n"
"    Signature: onPurge|void-void|ptr-oaTech,\n"
"    This function is called when an oaTech object is about to be purged from memory. The application's derived class should implement this function to receive notification when an oaTech object is about to be purged.\n"
"    tech\n"
"    A pointer to the oaTech about to be purged\n"
;

static PyObject*
oaObserver_oaTech_onPurge(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onPurge(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onTruncate_doc[] = 
"Class: oaObserver_oaTech, Function: onTruncate\n"
"  Paramegers: (oaTech)\n"
"    Calls: virtual void onTruncate(oaTech* tech)\n"
"    Signature: onTruncate|void-void|ptr-oaTech,\n"
"    This function is called just before an oaTech is truncated (for example, after all contents are removed). The application's derived class should implement this function to receive notification when an oaTech object is about to be truncated.\n"
"    tech\n"
"    A pointer to the oaTech about to be truncated\n"
;

static PyObject*
oaObserver_oaTech_onTruncate(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        data.DataCall()->oaObserver_oaTech::onTruncate(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onUnboundRef_doc[] = 
"Class: oaObserver_oaTech, Function: onUnboundRef\n"
"  Paramegers: (oaTech,oaTechHeader)\n"
"    Calls: virtual void onUnboundRef(oaTech* tech,oaTechHeader* header)\n"
"    Signature: onUnboundRef|void-void|ptr-oaTech,ptr-oaTechHeader,\n"
"    This function is called when an unbound reference to a technology database in the graph of referenced tech databases is detected when a technology database graph is opened using oaTech::open() . (This can occur when a referenced tech database is unavailable.)\n"
"    The application's derived class should implement this function to receive notification when there is an unbound reference to a tech database.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    tech\n"
"    Tech currently being opened\n"
"    header\n"
"    Unbound header specifying the tech database that is not available\n"
;

static PyObject*
oaObserver_oaTech_onUnboundRef(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTech p1;
    PyParamoaTechHeader p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaTechHeader_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        data.DataCall()->oaObserver_oaTech::onUnboundRef(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_onUserUnitsConflict_doc[] = 
"Class: oaObserver_oaTech, Function: onUserUnitsConflict\n"
"  Paramegers: (oaTechArray,oaViewType)\n"
"    Calls: virtual void onUserUnitsConflict(oaTechArray conflictingTechs,oaViewType* viewType)\n"
"    Signature: onUserUnitsConflict|void-void|simple-oaTechArray,ptr-oaViewType,\n"
"    oaTechObserver::onUserUnitsConflict\n"
"    This function is called when the UserUnits attribute has conflicting (non-equal) values in a graph of technology databases.\n"
"    This can occur when a tech database that is part of a graph of referenced techs is edited out of context and then reintroduced into the graph.\n"
"    The application's derived class should implement this function to receive notification when a tech database has a UserUnits attribute whose value conflicts with another UserUnits attribute in a different tech in the graph of tech databases.\n"
"    Refer to Incremental Technology Databases in the Using Technology Databases section of the Programmers Guide for more information about referenced tech databases.\n"
"    conflictingTechs\n"
"    Array of technology databases in which the attributes conflict. The first element in the array is the most derived tech in the graph.\n"
"    viewType\n"
"    Pointer to an oaViewType associated with the attribute.\n"
;

static PyObject*
oaObserver_oaTech_onUserUnitsConflict(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaObserver_oaTech data;
    int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
    assert(convert_status!=0);
    PyoaObserver_oaTechObject* self=(PyoaObserver_oaTechObject*)ob;

    PyParamoaTechArray p1;
    PyParamoaViewType p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechArray_Convert,&p1,
          &PyoaViewType_Convert,&p2)) {
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        data.DataCall()->oaObserver_oaTech::onUserUnitsConflict(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

static char oaObserver_oaTech_assign_doc[] = 
"Class: oaObserver_oaTech, Function: set\n"
"  Paramegers: (oaDouble)\n"
"    This function sets the current value.\n"
;

static PyObject*
oaObserver_oaTech_tp_assign(PyObject* ob, PyObject *args)
{
  PyParamoaObserver_oaTech data;
  int convert_status=PyoaObserver_oaTech_Convert(ob,&data);
  assert(convert_status!=0);
  try {
    PyParamoaObserver_oaTech p1;
    if (PyArg_ParseTuple(args,(char*)"O&",
          &PyoaObserver_oaTech_Convert,&p1)) {
        data.Data()=p1.Data();
        Py_INCREF(ob);
        return ob;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}


// ------------------------------------------------------------------
//  Function Methods Table:
// ------------------------------------------------------------------

static PyMethodDef oaObserver_oaTech_methodlist[] = {
    {"onClearanceMeasureConflict",(PyCFunction)oaObserver_oaTech_onClearanceMeasureConflict,METH_VARARGS,oaObserver_oaTech_onClearanceMeasureConflict_doc},
    {"onConflict",(PyCFunction)oaObserver_oaTech_onConflict,METH_VARARGS,oaObserver_oaTech_onConflict_doc},
    {"onCreate",(PyCFunction)oaObserver_oaTech_onCreate,METH_VARARGS,oaObserver_oaTech_onCreate_doc},
    {"onDBUPerUUConflict",(PyCFunction)oaObserver_oaTech_onDBUPerUUConflict,METH_VARARGS,oaObserver_oaTech_onDBUPerUUConflict_doc},
    {"onDefaultManufacturingGridConflict",(PyCFunction)oaObserver_oaTech_onDefaultManufacturingGridConflict,METH_VARARGS,oaObserver_oaTech_onDefaultManufacturingGridConflict_doc},
    {"onFirstOpen",(PyCFunction)oaObserver_oaTech_onFirstOpen,METH_VARARGS,oaObserver_oaTech_onFirstOpen_doc},
    {"onGateGroundedConflict",(PyCFunction)oaObserver_oaTech_onGateGroundedConflict,METH_VARARGS,oaObserver_oaTech_onGateGroundedConflict_doc},
    {"onPostAttach",(PyCFunction)oaObserver_oaTech_onPostAttach,METH_VARARGS,oaObserver_oaTech_onPostAttach_doc},
    {"onPostDetach",(PyCFunction)oaObserver_oaTech_onPostDetach,METH_VARARGS,oaObserver_oaTech_onPostDetach_doc},
    {"onPostModify",(PyCFunction)oaObserver_oaTech_onPostModify,METH_VARARGS,oaObserver_oaTech_onPostModify_doc},
    {"onPostOpenRefs",(PyCFunction)oaObserver_oaTech_onPostOpenRefs,METH_VARARGS,oaObserver_oaTech_onPostOpenRefs_doc},
    {"onPostReopen",(PyCFunction)oaObserver_oaTech_onPostReopen,METH_VARARGS,oaObserver_oaTech_onPostReopen_doc},
    {"onPostSave",(PyCFunction)oaObserver_oaTech_onPostSave,METH_VARARGS,oaObserver_oaTech_onPostSave_doc},
    {"onPostSaveAs",(PyCFunction)oaObserver_oaTech_onPostSaveAs,METH_VARARGS,oaObserver_oaTech_onPostSaveAs_doc},
    {"onPreAttach",(PyCFunction)oaObserver_oaTech_onPreAttach,METH_VARARGS,oaObserver_oaTech_onPreAttach_doc},
    {"onPreDetach",(PyCFunction)oaObserver_oaTech_onPreDetach,METH_VARARGS,oaObserver_oaTech_onPreDetach_doc},
    {"onPreModify",(PyCFunction)oaObserver_oaTech_onPreModify,METH_VARARGS,oaObserver_oaTech_onPreModify_doc},
    {"onPreOpenRefs",(PyCFunction)oaObserver_oaTech_onPreOpenRefs,METH_VARARGS,oaObserver_oaTech_onPreOpenRefs_doc},
    {"onPreReopen",(PyCFunction)oaObserver_oaTech_onPreReopen,METH_VARARGS,oaObserver_oaTech_onPreReopen_doc},
    {"onPreSave",(PyCFunction)oaObserver_oaTech_onPreSave,METH_VARARGS,oaObserver_oaTech_onPreSave_doc},
    {"onPreSaveAs",(PyCFunction)oaObserver_oaTech_onPreSaveAs,METH_VARARGS,oaObserver_oaTech_onPreSaveAs_doc},
    {"onPurge",(PyCFunction)oaObserver_oaTech_onPurge,METH_VARARGS,oaObserver_oaTech_onPurge_doc},
    {"onTruncate",(PyCFunction)oaObserver_oaTech_onTruncate,METH_VARARGS,oaObserver_oaTech_onTruncate_doc},
    {"onUnboundRef",(PyCFunction)oaObserver_oaTech_onUnboundRef,METH_VARARGS,oaObserver_oaTech_onUnboundRef_doc},
    {"onUserUnitsConflict",(PyCFunction)oaObserver_oaTech_onUserUnitsConflict,METH_VARARGS,oaObserver_oaTech_onUserUnitsConflict_doc},
    {"assign",(PyCFunction)oaObserver_oaTech_tp_assign,METH_VARARGS,oaObserver_oaTech_assign_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaTech_doc[] = 
"Class: oaObserver_oaTech\n"
"  This base template class can be used to derive observers for oaTech objects. It supports onCreate, onFirstOpen, onPreModify, onPostModify, onPurge, onPreSave, onPostSave, onPreSaveAs, onPostSaveAs, onPreReopen, onPostReopen, onTruncate, onConflict, onUnboundRef, onClearanceMeasureConflict, onDefaultManufacturingGridConflict, onGateGroundedConflict, onDBUPerUUConflict, onUserUnitsConflict, onPreOpenRefs, and onPostOpenRefs event notifications.\n"
"  See oaObserver for information on using Open Access observer template classes to derive and instantiate observers in an application.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaTech(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaTech||simple-oaUInt4,\n"
"    Constructor oaObserver_oaTech\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaTech_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaTech",
    sizeof(PyoaObserver_oaTechObject),
    0,
    (destructor)oaObserver_oaTech_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaTech_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaTech_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaTech_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    oaObserver_oaTech_methodlist,	/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaBaseObserver_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaTech_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
// Static FunctionMethods:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyClearanceMeasureConflictObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyClearanceMeasureConflictObservers\n"
"  Paramegers: (oaTechArray)\n"
"    Calls: void notifyClearanceMeasureConflictObservers(const oaTechArray& conflictingTechs)\n"
"    Signature: notifyClearanceMeasureConflictObservers|void-void|cref-oaTechArray,\n"
"    Function notifyClearanceMeasureConflictObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyClearanceMeasureConflictObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTechArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTechArray_Convert,&p1)) {
        oaObserver_oaTech::notifyClearanceMeasureConflictObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyConflictObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyConflictObservers\n"
"  Paramegers: (oaTech,oaTechConflictTypeEnum,oaObjectArray)\n"
"    Calls: void notifyConflictObservers(oaTech* mostDerivedTech,oaTechConflictTypeEnum conflictType,const oaObjectArray& conflictingObjs)\n"
"    Signature: notifyConflictObservers|void-void|ptr-oaTech,simple-oaTechConflictTypeEnum,cref-oaObjectArray,\n"
"    Function notifyConflictObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyConflictObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    PyParamoaTechConflictTypeEnum p2;
    PyParamoaObjectArray p3;
    if (PyArg_ParseTuple(args,"O&O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaTechConflictTypeEnum_Convert,&p2,
          &PyoaObjectArray_Convert,&p3)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyConflictObservers(p1.Data(),p2.Data(),p3.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyCreateObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyCreateObservers\n"
"  Paramegers: (oaTech)\n"
"    Calls: void notifyCreateObservers(oaTech* tech)\n"
"    Signature: notifyCreateObservers|void-void|ptr-oaTech,\n"
"    Function notifyCreateObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyCreateObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyCreateObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyDBUPerUUConflictObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyDBUPerUUConflictObservers\n"
"  Paramegers: (oaTechArray,oaViewType)\n"
"    Calls: void notifyDBUPerUUConflictObservers(const oaTechArray& conflictingTechs,oaViewType* viewType)\n"
"    Signature: notifyDBUPerUUConflictObservers|void-void|cref-oaTechArray,ptr-oaViewType,\n"
"    Function notifyDBUPerUUConflictObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyDBUPerUUConflictObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTechArray p1;
    PyParamoaViewType p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechArray_Convert,&p1,
          &PyoaViewType_Convert,&p2)) {
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        oaObserver_oaTech::notifyDBUPerUUConflictObservers(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyDefaultManufacturingGridConflictObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyDefaultManufacturingGridConflictObservers\n"
"  Paramegers: (oaTechArray)\n"
"    Calls: void notifyDefaultManufacturingGridConflictObservers(const oaTechArray& conflictingTechs)\n"
"    Signature: notifyDefaultManufacturingGridConflictObservers|void-void|cref-oaTechArray,\n"
"    Function notifyDefaultManufacturingGridConflictObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyDefaultManufacturingGridConflictObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTechArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTechArray_Convert,&p1)) {
        oaObserver_oaTech::notifyDefaultManufacturingGridConflictObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyFirstOpenObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyFirstOpenObservers\n"
"  Paramegers: (oaTech)\n"
"    Calls: void notifyFirstOpenObservers(oaTech* tech)\n"
"    Signature: notifyFirstOpenObservers|void-void|ptr-oaTech,\n"
"    Function notifyFirstOpenObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyFirstOpenObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyFirstOpenObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyGateGroundedConflictObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyGateGroundedConflictObservers\n"
"  Paramegers: (oaTechArray)\n"
"    Calls: void notifyGateGroundedConflictObservers(const oaTechArray& conflictingTechs)\n"
"    Signature: notifyGateGroundedConflictObservers|void-void|cref-oaTechArray,\n"
"    Function notifyGateGroundedConflictObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyGateGroundedConflictObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTechArray p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTechArray_Convert,&p1)) {
        oaObserver_oaTech::notifyGateGroundedConflictObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyPostAttachObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyPostAttachObservers\n"
"  Paramegers: (oaLib,oaScalarName)\n"
"    Calls: void notifyPostAttachObservers(oaLib* lib,const oaScalarName& attachLibName)\n"
"    Signature: notifyPostAttachObservers|void-void|ptr-oaLib,cref-oaScalarName,\n"
"    Function notifyPostAttachObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyPostAttachObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaLib p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaLib_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyPostAttachObservers(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyPostDetachObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyPostDetachObservers\n"
"  Paramegers: (oaLib)\n"
"    Calls: void notifyPostDetachObservers(oaLib* lib)\n"
"    Signature: notifyPostDetachObservers|void-void|ptr-oaLib,\n"
"    Function notifyPostDetachObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyPostDetachObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaLib p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaLib_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyPostDetachObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyPostModifyObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyPostModifyObservers\n"
"  Paramegers: (oaTech,oaTechModTypeEnum)\n"
"    Calls: void notifyPostModifyObservers(oaTech* tech,oaTechModTypeEnum modType)\n"
"    Signature: notifyPostModifyObservers|void-void|ptr-oaTech,simple-oaTechModTypeEnum,\n"
"    Function notifyPostModifyObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyPostModifyObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    PyParamoaTechModTypeEnum p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaTechModTypeEnum_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyPostModifyObservers(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyPostOpenRefsObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyPostOpenRefsObservers\n"
"  Paramegers: (oaTech)\n"
"    Calls: void notifyPostOpenRefsObservers(oaTech* tech)\n"
"    Signature: notifyPostOpenRefsObservers|void-void|ptr-oaTech,\n"
"    Function notifyPostOpenRefsObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyPostOpenRefsObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyPostOpenRefsObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyPostReopenObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyPostReopenObservers\n"
"  Paramegers: (oaTech,oaChar)\n"
"    Calls: void notifyPostReopenObservers(oaTech* tech,oaChar oldMode)\n"
"    Signature: notifyPostReopenObservers|void-void|ptr-oaTech,simple-oaChar,\n"
"    Function notifyPostReopenObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyPostReopenObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    PyParamoaChar p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaChar_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyPostReopenObservers(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyPostSaveAsObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyPostSaveAsObservers\n"
"  Paramegers: (oaTech,oaBoolean)\n"
"    Calls: void notifyPostSaveAsObservers(oaTech* tech,oaBoolean succeeded)\n"
"    Signature: notifyPostSaveAsObservers|void-void|ptr-oaTech,simple-oaBoolean,\n"
"    Function notifyPostSaveAsObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyPostSaveAsObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyPostSaveAsObservers(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyPostSaveObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyPostSaveObservers\n"
"  Paramegers: (oaTech,oaBoolean)\n"
"    Calls: void notifyPostSaveObservers(oaTech* tech,oaBoolean succeeded)\n"
"    Signature: notifyPostSaveObservers|void-void|ptr-oaTech,simple-oaBoolean,\n"
"    Function notifyPostSaveObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyPostSaveObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    PyParamoaBoolean p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaBoolean_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyPostSaveObservers(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyPreAttachObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyPreAttachObservers\n"
"  Paramegers: (oaLib,oaScalarName)\n"
"    Calls: void notifyPreAttachObservers(oaLib* lib,const oaScalarName& attachLibName)\n"
"    Signature: notifyPreAttachObservers|void-void|ptr-oaLib,cref-oaScalarName,\n"
"    Function notifyPreAttachObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyPreAttachObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaLib p1;
    PyParamoaScalarName p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaLib_Convert,&p1,
          &PyoaScalarName_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyPreAttachObservers(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyPreDetachObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyPreDetachObservers\n"
"  Paramegers: (oaLib)\n"
"    Calls: void notifyPreDetachObservers(oaLib* lib)\n"
"    Signature: notifyPreDetachObservers|void-void|ptr-oaLib,\n"
"    Function notifyPreDetachObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyPreDetachObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaLib p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaLib_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyPreDetachObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyPreModifyObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyPreModifyObservers\n"
"  Paramegers: (oaTech,oaTechModTypeEnum)\n"
"    Calls: void notifyPreModifyObservers(oaTech* tech,oaTechModTypeEnum modType)\n"
"    Signature: notifyPreModifyObservers|void-void|ptr-oaTech,simple-oaTechModTypeEnum,\n"
"    Function notifyPreModifyObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyPreModifyObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    PyParamoaTechModTypeEnum p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaTechModTypeEnum_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyPreModifyObservers(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyPreOpenRefsObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyPreOpenRefsObservers\n"
"  Paramegers: (oaTech)\n"
"    Calls: void notifyPreOpenRefsObservers(oaTech* tech)\n"
"    Signature: notifyPreOpenRefsObservers|void-void|ptr-oaTech,\n"
"    Function notifyPreOpenRefsObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyPreOpenRefsObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyPreOpenRefsObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyPreReopenObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyPreReopenObservers\n"
"  Paramegers: (oaTech,oaChar)\n"
"    Calls: void notifyPreReopenObservers(oaTech* tech,oaChar newMode)\n"
"    Signature: notifyPreReopenObservers|void-void|ptr-oaTech,simple-oaChar,\n"
"    Function notifyPreReopenObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyPreReopenObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    PyParamoaChar p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaChar_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyPreReopenObservers(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyPreSaveAsObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyPreSaveAsObservers\n"
"  Paramegers: (oaTech)\n"
"    Calls: void notifyPreSaveAsObservers(oaTech* tech)\n"
"    Signature: notifyPreSaveAsObservers|void-void|ptr-oaTech,\n"
"    Function notifyPreSaveAsObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyPreSaveAsObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyPreSaveAsObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyPreSaveObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyPreSaveObservers\n"
"  Paramegers: (oaTech)\n"
"    Calls: void notifyPreSaveObservers(oaTech* tech)\n"
"    Signature: notifyPreSaveObservers|void-void|ptr-oaTech,\n"
"    Function notifyPreSaveObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyPreSaveObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyPreSaveObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyPurgeObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyPurgeObservers\n"
"  Paramegers: (oaTech)\n"
"    Calls: void notifyPurgeObservers(oaTech* tech)\n"
"    Signature: notifyPurgeObservers|void-void|ptr-oaTech,\n"
"    Function notifyPurgeObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyPurgeObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyPurgeObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyTruncateObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyTruncateObservers\n"
"  Paramegers: (oaTech)\n"
"    Calls: void notifyTruncateObservers(oaTech* tech)\n"
"    Signature: notifyTruncateObservers|void-void|ptr-oaTech,\n"
"    Function notifyTruncateObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyTruncateObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    if (PyArg_ParseTuple(args,"O&",
          &PyoaTech_Convert,&p1)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        oaObserver_oaTech::notifyTruncateObservers(p1.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyUnboundRefObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyUnboundRefObservers\n"
"  Paramegers: (oaTech,oaTechHeader)\n"
"    Calls: void notifyUnboundRefObservers(oaTech* tech,oaTechHeader* header)\n"
"    Signature: notifyUnboundRefObservers|void-void|ptr-oaTech,ptr-oaTechHeader,\n"
"    Function notifyUnboundRefObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyUnboundRefObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTech p1;
    PyParamoaTechHeader p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTech_Convert,&p1,
          &PyoaTechHeader_Convert,&p2)) {
        if (!PyValidateDbObject(p1.Data(),1)) return NULL;
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        oaObserver_oaTech::notifyUnboundRefObservers(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static char oaObserver_oaTech_static_notifyUserUnitsConflictObservers_doc[] = 
"Class: oaObserver_oaTech, Function: notifyUserUnitsConflictObservers\n"
"  Paramegers: (oaTechArray,oaViewType)\n"
"    Calls: void notifyUserUnitsConflictObservers(const oaTechArray& conflictingTechs,oaViewType* viewType)\n"
"    Signature: notifyUserUnitsConflictObservers|void-void|cref-oaTechArray,ptr-oaViewType,\n"
"    Function notifyUserUnitsConflictObservers\n"
;

static PyObject*
oaObserver_oaTech_static_notifyUserUnitsConflictObservers(PyObject* ob, PyObject *args)
{
  try {
    PyParamoaTechArray p1;
    PyParamoaViewType p2;
    if (PyArg_ParseTuple(args,"O&O&",
          &PyoaTechArray_Convert,&p1,
          &PyoaViewType_Convert,&p2)) {
        if (!PyValidateDbObject(p2.Data(),2)) return NULL;
        oaObserver_oaTech::notifyUserUnitsConflictObservers(p1.Data(),p2.Data());
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static PyMethodDef oaObserver_oaTech_staticmethodlist[] = {
    {"static_notifyClearanceMeasureConflictObservers",(PyCFunction)oaObserver_oaTech_static_notifyClearanceMeasureConflictObservers,METH_VARARGS,oaObserver_oaTech_static_notifyClearanceMeasureConflictObservers_doc},
    {"static_notifyConflictObservers",(PyCFunction)oaObserver_oaTech_static_notifyConflictObservers,METH_VARARGS,oaObserver_oaTech_static_notifyConflictObservers_doc},
    {"static_notifyCreateObservers",(PyCFunction)oaObserver_oaTech_static_notifyCreateObservers,METH_VARARGS,oaObserver_oaTech_static_notifyCreateObservers_doc},
    {"static_notifyDBUPerUUConflictObservers",(PyCFunction)oaObserver_oaTech_static_notifyDBUPerUUConflictObservers,METH_VARARGS,oaObserver_oaTech_static_notifyDBUPerUUConflictObservers_doc},
    {"static_notifyDefaultManufacturingGridConflictObservers",(PyCFunction)oaObserver_oaTech_static_notifyDefaultManufacturingGridConflictObservers,METH_VARARGS,oaObserver_oaTech_static_notifyDefaultManufacturingGridConflictObservers_doc},
    {"static_notifyFirstOpenObservers",(PyCFunction)oaObserver_oaTech_static_notifyFirstOpenObservers,METH_VARARGS,oaObserver_oaTech_static_notifyFirstOpenObservers_doc},
    {"static_notifyGateGroundedConflictObservers",(PyCFunction)oaObserver_oaTech_static_notifyGateGroundedConflictObservers,METH_VARARGS,oaObserver_oaTech_static_notifyGateGroundedConflictObservers_doc},
    {"static_notifyPostAttachObservers",(PyCFunction)oaObserver_oaTech_static_notifyPostAttachObservers,METH_VARARGS,oaObserver_oaTech_static_notifyPostAttachObservers_doc},
    {"static_notifyPostDetachObservers",(PyCFunction)oaObserver_oaTech_static_notifyPostDetachObservers,METH_VARARGS,oaObserver_oaTech_static_notifyPostDetachObservers_doc},
    {"static_notifyPostModifyObservers",(PyCFunction)oaObserver_oaTech_static_notifyPostModifyObservers,METH_VARARGS,oaObserver_oaTech_static_notifyPostModifyObservers_doc},
    {"static_notifyPostOpenRefsObservers",(PyCFunction)oaObserver_oaTech_static_notifyPostOpenRefsObservers,METH_VARARGS,oaObserver_oaTech_static_notifyPostOpenRefsObservers_doc},
    {"static_notifyPostReopenObservers",(PyCFunction)oaObserver_oaTech_static_notifyPostReopenObservers,METH_VARARGS,oaObserver_oaTech_static_notifyPostReopenObservers_doc},
    {"static_notifyPostSaveAsObservers",(PyCFunction)oaObserver_oaTech_static_notifyPostSaveAsObservers,METH_VARARGS,oaObserver_oaTech_static_notifyPostSaveAsObservers_doc},
    {"static_notifyPostSaveObservers",(PyCFunction)oaObserver_oaTech_static_notifyPostSaveObservers,METH_VARARGS,oaObserver_oaTech_static_notifyPostSaveObservers_doc},
    {"static_notifyPreAttachObservers",(PyCFunction)oaObserver_oaTech_static_notifyPreAttachObservers,METH_VARARGS,oaObserver_oaTech_static_notifyPreAttachObservers_doc},
    {"static_notifyPreDetachObservers",(PyCFunction)oaObserver_oaTech_static_notifyPreDetachObservers,METH_VARARGS,oaObserver_oaTech_static_notifyPreDetachObservers_doc},
    {"static_notifyPreModifyObservers",(PyCFunction)oaObserver_oaTech_static_notifyPreModifyObservers,METH_VARARGS,oaObserver_oaTech_static_notifyPreModifyObservers_doc},
    {"static_notifyPreOpenRefsObservers",(PyCFunction)oaObserver_oaTech_static_notifyPreOpenRefsObservers,METH_VARARGS,oaObserver_oaTech_static_notifyPreOpenRefsObservers_doc},
    {"static_notifyPreReopenObservers",(PyCFunction)oaObserver_oaTech_static_notifyPreReopenObservers,METH_VARARGS,oaObserver_oaTech_static_notifyPreReopenObservers_doc},
    {"static_notifyPreSaveAsObservers",(PyCFunction)oaObserver_oaTech_static_notifyPreSaveAsObservers,METH_VARARGS,oaObserver_oaTech_static_notifyPreSaveAsObservers_doc},
    {"static_notifyPreSaveObservers",(PyCFunction)oaObserver_oaTech_static_notifyPreSaveObservers,METH_VARARGS,oaObserver_oaTech_static_notifyPreSaveObservers_doc},
    {"static_notifyPurgeObservers",(PyCFunction)oaObserver_oaTech_static_notifyPurgeObservers,METH_VARARGS,oaObserver_oaTech_static_notifyPurgeObservers_doc},
    {"static_notifyTruncateObservers",(PyCFunction)oaObserver_oaTech_static_notifyTruncateObservers,METH_VARARGS,oaObserver_oaTech_static_notifyTruncateObservers_doc},
    {"static_notifyUnboundRefObservers",(PyCFunction)oaObserver_oaTech_static_notifyUnboundRefObservers,METH_VARARGS,oaObserver_oaTech_static_notifyUnboundRefObservers_doc},
    {"static_notifyUserUnitsConflictObservers",(PyCFunction)oaObserver_oaTech_static_notifyUserUnitsConflictObservers,METH_VARARGS,oaObserver_oaTech_static_notifyUserUnitsConflictObservers_doc},
   {NULL,NULL,0,NULL}
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaTech_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaTech_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaTech\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaTech",
           (PyObject*)(&PyoaObserver_oaTech_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaTech\n");
       return -1;
    }

    PyObject *dict, *value;
    PyMethodDef *method;
    dict=PyoaObserver_oaTech_Type.tp_dict;
    for(method=oaObserver_oaTech_staticmethodlist;method->ml_name!=NULL;method++) {
        value=PyCFunction_New(method,NULL);
    if (value==NULL) return -1;
        if (PyDict_SetItemString(dict,method->ml_name,value)!=0) {
        Py_DECREF(value);
            printf("** Failed to add static function to module dictionary for: %s\n",
                method->ml_name);
            return -1;
        }
        Py_DECREF(value);
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaTechHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaTechHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaTechHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaTechHeaderObject* self = (PyoaObserver_oaTechHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaTechHeader(p1.Data());
            }
            else {
                pyv_oaObserver_oaTechHeader* p=new pyv_oaObserver_oaTechHeader(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaTechHeader(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaTechHeader* p=new pyv_oaObserver_oaTechHeader(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaTechHeader)
    {
        PyParamoaObserver_oaTechHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaTechHeader_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaTechHeader(p1.Data());
            }
            else {
                pyv_oaObserver_oaTechHeader* p=new pyv_oaObserver_oaTechHeader(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaTechHeader, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaTechHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaTechHeader_tp_dealloc(PyoaObserver_oaTechHeaderObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaTechHeader*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaTechHeader_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaTechHeader value;
    int convert_status=PyoaObserver_oaTechHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[45];
    sprintf(buffer,"<oaObserver_oaTechHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaTechHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaTechHeader v1;
    PyParamoaObserver_oaTechHeader v2;
    int convert_status1=PyoaObserver_oaTechHeader_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaTechHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaTechHeader_Convert(PyObject* ob,PyParamoaObserver_oaTechHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaTechHeader_Check(ob)) {
        result->SetData( (oaObserver_oaTechHeader*) ((PyoaObserver_oaTechHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaTechHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaTechHeader_FromoaObserver_oaTechHeader(oaObserver_oaTechHeader* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaTechHeader_Type.tp_alloc(&PyoaObserver_oaTechHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaTechHeaderObject* self = (PyoaObserver_oaTechHeaderObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaTechHeader::pyv_oaObserver_oaTechHeader(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaTechHeader(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaTechHeader::pyv_oaObserver_oaTechHeader(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaTechHeader(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaTechHeader::pyv_oaObserver_oaTechHeader(const oaObserver_oaTechHeader& p)
 : pyob(NULL),
   oaObserver_oaTechHeader(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTechHeader::onPostCreate(oaTechHeader* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTechHeader::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTechHeader_FromoaTechHeader(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTechHeader::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTechHeader::onPostModify(oaTechHeader* p1,oaTechHeaderModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTechHeader::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaTechHeader_FromoaTechHeader(p1));
    PyTuple_SetItem(args,1,PyoaTechHeaderModTypeEnum_FromoaTechHeaderModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTechHeader::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTechHeader::onPreDestroy(oaTechHeader* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTechHeader::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTechHeader_FromoaTechHeader(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTechHeader::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTechHeader::onPreModify(oaTechHeader* p1,oaTechHeaderModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTechHeader::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaTechHeader_FromoaTechHeader(p1));
    PyTuple_SetItem(args,1,PyoaTechHeaderModTypeEnum_FromoaTechHeaderModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTechHeader::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaTechHeader_doc[] = 
"Class: oaObserver_oaTechHeader\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaTechHeader(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaTechHeader||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaTechHeader\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaTechHeader(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaTechHeader||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaTechHeader\n"
"  Paramegers: (oaObserver_oaTechHeader)\n"
"    Calls: (const oaObserver_oaTechHeader&)\n"
"    Signature: oaObserver_oaTechHeader||cref-oaObserver_oaTechHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaTechHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaTechHeader",
    sizeof(PyoaObserver_oaTechHeaderObject),
    0,
    (destructor)oaObserver_oaTechHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaTechHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaTechHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaTechHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaTechHeader_oaTechHeaderModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaTechHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaTechHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaTechHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaTechHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaTechHeader",
           (PyObject*)(&PyoaObserver_oaTechHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaTechHeader\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaTechLayerHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaTechLayerHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaTechLayerHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaTechLayerHeaderObject* self = (PyoaObserver_oaTechLayerHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaTechLayerHeader(p1.Data());
            }
            else {
                pyv_oaObserver_oaTechLayerHeader* p=new pyv_oaObserver_oaTechLayerHeader(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaTechLayerHeader(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaTechLayerHeader* p=new pyv_oaObserver_oaTechLayerHeader(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaTechLayerHeader)
    {
        PyParamoaObserver_oaTechLayerHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaTechLayerHeader_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaTechLayerHeader(p1.Data());
            }
            else {
                pyv_oaObserver_oaTechLayerHeader* p=new pyv_oaObserver_oaTechLayerHeader(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaTechLayerHeader, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaTechLayerHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaTechLayerHeader_tp_dealloc(PyoaObserver_oaTechLayerHeaderObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaTechLayerHeader*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaTechLayerHeader_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaTechLayerHeader value;
    int convert_status=PyoaObserver_oaTechLayerHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[50];
    sprintf(buffer,"<oaObserver_oaTechLayerHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaTechLayerHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaTechLayerHeader v1;
    PyParamoaObserver_oaTechLayerHeader v2;
    int convert_status1=PyoaObserver_oaTechLayerHeader_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaTechLayerHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaTechLayerHeader_Convert(PyObject* ob,PyParamoaObserver_oaTechLayerHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaTechLayerHeader_Check(ob)) {
        result->SetData( (oaObserver_oaTechLayerHeader*) ((PyoaObserver_oaTechLayerHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaTechLayerHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaTechLayerHeader_FromoaObserver_oaTechLayerHeader(oaObserver_oaTechLayerHeader* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaTechLayerHeader_Type.tp_alloc(&PyoaObserver_oaTechLayerHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaTechLayerHeaderObject* self = (PyoaObserver_oaTechLayerHeaderObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaTechLayerHeader::pyv_oaObserver_oaTechLayerHeader(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaTechLayerHeader(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaTechLayerHeader::pyv_oaObserver_oaTechLayerHeader(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaTechLayerHeader(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaTechLayerHeader::pyv_oaObserver_oaTechLayerHeader(const oaObserver_oaTechLayerHeader& p)
 : pyob(NULL),
   oaObserver_oaTechLayerHeader(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTechLayerHeader::onPostCreate(oaTechLayerHeader* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTechLayerHeader::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTechLayerHeader_FromoaTechLayerHeader(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTechLayerHeader::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTechLayerHeader::onPostModify(oaTechLayerHeader* p1,oaTechLayerHeaderModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTechLayerHeader::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaTechLayerHeader_FromoaTechLayerHeader(p1));
    PyTuple_SetItem(args,1,PyoaTechLayerHeaderModTypeEnum_FromoaTechLayerHeaderModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTechLayerHeader::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTechLayerHeader::onPreDestroy(oaTechLayerHeader* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTechLayerHeader::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTechLayerHeader_FromoaTechLayerHeader(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTechLayerHeader::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTechLayerHeader::onPreModify(oaTechLayerHeader* p1,oaTechLayerHeaderModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTechLayerHeader::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaTechLayerHeader_FromoaTechLayerHeader(p1));
    PyTuple_SetItem(args,1,PyoaTechLayerHeaderModTypeEnum_FromoaTechLayerHeaderModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTechLayerHeader::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaTechLayerHeader_doc[] = 
"Class: oaObserver_oaTechLayerHeader\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaTechLayerHeader(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaTechLayerHeader||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaTechLayerHeader\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaTechLayerHeader(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaTechLayerHeader||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaTechLayerHeader\n"
"  Paramegers: (oaObserver_oaTechLayerHeader)\n"
"    Calls: (const oaObserver_oaTechLayerHeader&)\n"
"    Signature: oaObserver_oaTechLayerHeader||cref-oaObserver_oaTechLayerHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaTechLayerHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaTechLayerHeader",
    sizeof(PyoaObserver_oaTechLayerHeaderObject),
    0,
    (destructor)oaObserver_oaTechLayerHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaTechLayerHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaTechLayerHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaTechLayerHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaTechLayerHeader_oaTechLayerHeaderModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaTechLayerHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaTechLayerHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaTechLayerHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaTechLayerHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaTechLayerHeader",
           (PyObject*)(&PyoaObserver_oaTechLayerHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaTechLayerHeader\n");
       return -1;
    }
    return 0;
}


/********************************************************************
 *   Copyright 2002-2008  LSI Corporation
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *******************************************************************/

#include "pyoa_header.h"


// ==================================================================
// Wrapper Implementation for Class: oaObserver_oaTechViaDefHeader
// ==================================================================


// ==================================================================
// Alloc/Dealloc Routines
// ==================================================================

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaTechViaDefHeader_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  try {
    int is_raw=(type==&PyoaObserver_oaTechViaDefHeader_Type);
    PyObject* bself = type->tp_alloc(type,0);
    if (bself == NULL) return bself;
    PyoaObserver_oaTechViaDefHeaderObject* self = (PyoaObserver_oaTechViaDefHeaderObject*)bself;
    self->locks = NULL;
    self->borrow = 0;
    static char *kwlist [] = { NULL } ;
    // Case: (oaUInt4)
    {
        PyParamoaUInt4 p1;
        if (PyArg_ParseTuple(args,"O&",
              &PyoaUInt4_Convert,&p1)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaTechViaDefHeader(p1.Data());
            }
            else {
                pyv_oaObserver_oaTechViaDefHeader* p=new pyv_oaObserver_oaTechViaDefHeader(p1.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaUInt4,oaBoolean)
    {
        PyParamoaUInt4 p1;
        PyParamoaBoolean p2;
        if (PyArg_ParseTuple(args,"O&O&",
              &PyoaUInt4_Convert,&p1,
              &PyoaBoolean_Convert,&p2)) {
            if (is_raw) {
                self->value = (oaBaseObserver*)  new oaObserver_oaTechViaDefHeader(p1.Data(),p2.Data());
            }
            else {
                pyv_oaObserver_oaTechViaDefHeader* p=new pyv_oaObserver_oaTechViaDefHeader(p1.Data(),p2.Data());
                p->pyob=self;
                self->value= (oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    // Case: (oaObserver_oaTechViaDefHeader)
    {
        PyParamoaObserver_oaTechViaDefHeader p1;
        if (PyArg_ParseTuple(args,(char*)"O&",
              &PyoaObserver_oaTechViaDefHeader_Convert,&p1)) {
            if (is_raw) {
                self->value=(oaBaseObserver*)  new oaObserver_oaTechViaDefHeader(p1.Data());
            }
            else {
                pyv_oaObserver_oaTechViaDefHeader* p=new pyv_oaObserver_oaTechViaDefHeader(p1.Data());
            p->pyob=self;
                self->value=(oaBaseObserver*) p;
            }
            return bself;
        }
    }
    PyErr_Clear();
    PyErr_SetString(PyExc_TypeError,
        "No Arg-Matching Constructor found for class: oaObserver_oaTechViaDefHeader, Choices are:\n"
        "    (oaUInt4)\n"
        "    (oaUInt4,oaBoolean)\n"
        "    (oaObserver_oaTechViaDefHeader)\n"
    );
    Py_DECREF(self);
    return NULL;
  }
  catch (oaException &excp) {
    PyErr_OpenAccess(excp);
    return NULL;
  }
}

// ------------------------------------------------------------------
static void
oaObserver_oaTechViaDefHeader_tp_dealloc(PyoaObserver_oaTechViaDefHeaderObject* self)
{
    if (!self->borrow) {
        delete (oaObserver_oaTechViaDefHeader*)(self->value);
    }
    Py_XDECREF(self->locks);
    self->ob_type->tp_free((PyObject*)self);
}

// ------------------------------------------------------------------
static PyObject*
oaObserver_oaTechViaDefHeader_tp_repr(PyObject *ob)
{
    PyParamoaObserver_oaTechViaDefHeader value;
    int convert_status=PyoaObserver_oaTechViaDefHeader_Convert(ob,&value);
    assert(convert_status!=0);
    PyObject* result;

    char buffer[51];
    sprintf(buffer,"<oaObserver_oaTechViaDefHeader::" DISPLAY_FORMAT ">",POINTER_AS_DISPLAY(value.DataCall()));
    result=PyString_FromString(buffer);
    return result;
}
        
// ------------------------------------------------------------------
static int
oaObserver_oaTechViaDefHeader_tp_compare(PyObject *ob1,PyObject* ob2)
{
    PyParamoaObserver_oaTechViaDefHeader v1;
    PyParamoaObserver_oaTechViaDefHeader v2;
    int convert_status1=PyoaObserver_oaTechViaDefHeader_Convert(ob1,&v1);
    int convert_status2=PyoaObserver_oaTechViaDefHeader_Convert(ob2,&v2);
    assert(convert_status1!=0);
    assert(convert_status2!=0);
    if (v1.DataCall()==v2.DataCall()) return 0;
    return 1;
}
        
// ------------------------------------------------------------------
int
PyoaObserver_oaTechViaDefHeader_Convert(PyObject* ob,PyParamoaObserver_oaTechViaDefHeader* result)
{
    if (ob == NULL) return 1;
    if (PyoaObserver_oaTechViaDefHeader_Check(ob)) {
        result->SetData( (oaObserver_oaTechViaDefHeader*) ((PyoaObserver_oaTechViaDefHeaderObject*)ob)->value);
        return 1;
    }
    PyErr_SetString(PyExc_TypeError,
        "Convertion of parameter to class: oaObserver_oaTechViaDefHeader Failed");
    return 0;
}
// ------------------------------------------------------------------
PyObject* PyoaObserver_oaTechViaDefHeader_FromoaObserver_oaTechViaDefHeader(oaObserver_oaTechViaDefHeader* data,int borrow,PyObject* lock)
{
    if (data) {
        PyObject* bself = PyoaObserver_oaTechViaDefHeader_Type.tp_alloc(&PyoaObserver_oaTechViaDefHeader_Type,0);
        if (bself == NULL) return bself;
        PyoaObserver_oaTechViaDefHeaderObject* self = (PyoaObserver_oaTechViaDefHeaderObject*)bself;
        self->value = (oaBaseObserver*)  data;
        self->locks = NULL;
        self->borrow = borrow;
        if (lock) PyoaLockObject(self->locks,lock);
        return bself;
    }
    Py_INCREF(Py_None);
    return Py_None;
}

// ------------------------------------------------------------------
// Virtual Functions:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
pyv_oaObserver_oaTechViaDefHeader::pyv_oaObserver_oaTechViaDefHeader(oaUInt4 p1)
 : pyob(NULL),
   oaObserver_oaTechViaDefHeader(p1)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaTechViaDefHeader::pyv_oaObserver_oaTechViaDefHeader(oaUInt4 p1,oaBoolean p2)
 : pyob(NULL),
   oaObserver_oaTechViaDefHeader(p1,p2)
{
}

// ------------------------------------------------------------------
pyv_oaObserver_oaTechViaDefHeader::pyv_oaObserver_oaTechViaDefHeader(const oaObserver_oaTechViaDefHeader& p)
 : pyob(NULL),
   oaObserver_oaTechViaDefHeader(p)
{
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTechViaDefHeader::onPostCreate(oaTechViaDefHeader* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostCreate");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTechViaDefHeader::onPostCreate was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTechViaDefHeader_FromoaTechViaDefHeader(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTechViaDefHeader::onPostCreate had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTechViaDefHeader::onPostModify(oaTechViaDefHeader* p1,oaTechViaDefHeaderModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPostModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTechViaDefHeader::onPostModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaTechViaDefHeader_FromoaTechViaDefHeader(p1));
    PyTuple_SetItem(args,1,PyoaTechViaDefHeaderModTypeEnum_FromoaTechViaDefHeaderModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTechViaDefHeader::onPostModify had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTechViaDefHeader::onPreDestroy(oaTechViaDefHeader* p1)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreDestroy");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTechViaDefHeader::onPreDestroy was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(1);
    PyTuple_SetItem(args,0,PyoaTechViaDefHeader_FromoaTechViaDefHeader(p1));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTechViaDefHeader::onPreDestroy had an error.");
    }
    Py_DECREF(result);
}

// ------------------------------------------------------------------
void pyv_oaObserver_oaTechViaDefHeader::onPreModify(oaTechViaDefHeader* p1,oaTechViaDefHeaderModTypeEnum p2)
{
    PyObject* md=PyObject_GetAttrString((PyObject*)pyob,"onPreModify");
    if (!PyCallable_Check(md)) {
        Py_DECREF(md);
        throw oaPythonException("Python Virtual Function oaObserver_oaTechViaDefHeader::onPreModify was unable to find a callable python routine.");
    }
    PyObject* args=PyTuple_New(2);
    PyTuple_SetItem(args,0,PyoaTechViaDefHeader_FromoaTechViaDefHeader(p1));
    PyTuple_SetItem(args,1,PyoaTechViaDefHeaderModTypeEnum_FromoaTechViaDefHeaderModTypeEnum(p2));
    PyObject* result=PyObject_CallObject(md,args);
    Py_DECREF(md);
    Py_DECREF(args);
    if (result==NULL) {
        throw oaPythonException("Python Virtual Function oaObserver_oaTechViaDefHeader::onPreModify had an error.");
    }
    Py_DECREF(result);
}


// ------------------------------------------------------------------
//  Type Object:
// ------------------------------------------------------------------

// ------------------------------------------------------------------
static char oaObserver_oaTechViaDefHeader_doc[] = 
"Class: oaObserver_oaTechViaDefHeader\n"
"  Observers are a set of classes that allow applications to request notification whenever certain changes occur to the state and contents of open databases. This allows a complex application to keep its internal state consistent with changes made by other code in the same process.\n"
"  The oaObserver<> class is an abstract template class used as the base class for observers in OpenAccess. OpenAccess defines which classes can have observers, and what the modification enum is for observers that provide modification notification. Observers are allowed at a certain level of the managed class hierarchy where the observer is expected to map to the needs of applications. For example, there is no oaFig observer. All the observers for figures are at a lower level of the class hierarchy. There is an observer for oaShapes. There is no observer specific to oaRects, and an application that only wants to know about changes to oaRects would have to create an oaShape observer and test the type of the shape in its oaShape observer notification functions. The OpenAccess Observer Table , below, lists the available OpenAccess observers and provides information about the notifications associated with each observer and the modification enum associated with each observer that provides modification notifications (see Observer Notification Functions for additional information).\n"
"  Callers use observers by:\n"
"  declaring their own derived class that inherits from the appropriate Observer<> base class. For a list of available observer template classes from which users can derive their own observer classes, see the Observer<oaClassName> (leftmost) column of the OpenAccess Observer Table , below.\n"
"  implementing virtual notification functions that correspond to events for which callers are requesting notification. For a description of the different notification functions associated with different observers, see Observer Notification Functions , below.\n"
"  constructing an instance of the derived class in order to register its functions in a given application.\n"
"  Observer Enable and Priority Settings\n"
"  Two important capabilities of all OpenAccess observer base classes are the following:\n"
"  1) Observers can be enabled or disabled as desired (either during construction -- or by calling the observer's enable() function). Disabled observers are not called. The enabled status of an observer can be checked by calling isEnabled().\n"
"  2) Observers are ordered by priority. Observers with higher priority (which means those with lower priority numbers) are called first. The priority of each observer is established during construction of the observer (see ).\n"
"  Observer Notification Functions\n"
"  The OpenAccess Observer hierarchy implements a standard set of observer notification functions, as described in Standard Notifications . OpenAccess also implements specialized notification functions for particular oaObserver classes, which are categorized as special notifications below.\n"
"  Note: The notification function category associated with each observer is listed in the Notification Functions (middle) column of the OpenAccess Observer Table, below.\n"
"  Standard Notifications\n"
"  Standard observers, which are derived from oaStdObserver , provide notification of object creation, destruction and modification, as follows:\n"
"  class myLibDefListObserver : public oaObserver<oaLibDefList> { public : myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn = true ); oaBoolean onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type); }; myLibDefListObserver::myLibDefListObserver(oaUInt4 priorityIn, oaBoolean enabledIn) :oaObserver< oaLibDefList >(priorityIn, enabledIn) { } oaBoolean myLibDefListObserver::onLoadWarnings( oaLibDefList *obj, const oaString &msg, oaLibDefListWarningTypeEnum type) { if (!obj) { cout << \"Error trying to open default libs.def file: \" << msg << endl; } else { oaString libDefPath; obj-> getPath (libDefPath); switch (type) { case oacSyntaxErrorLibDefListWarning: cout << \"Syntax error in \" << libDefPath << \": \" << msg << endl; break ; default : cout << libDefPath << \" load warning: \" << msg << endl; break ; } } return true ; }\n"
"  oaObserver Class Implementation Notes\n"
"  The oaObserver template class and its specializations are defined as oaVersionedObserver template and its corresponding specializations. This template has an additional non-type template argument for the version of the observer. The oaObserver identifier is defined in the header files as oaVersionedObserver. This is required to add new virtual functions to the specialization (such as the specialization for oaTech ). Application code must reference oaObserver. Direct reference of oaVersionedObserver is not supported. The implementation of the oaObserver class is transparent and applications must use oaObserver directly as before.\n"
"Constructors:\n"
"  Paramegers: (oaUInt4)\n"
"    Calls: oaObserver_oaTechViaDefHeader(oaUInt4 priorityIn)\n"
"    Signature: oaObserver_oaTechViaDefHeader||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaTechViaDefHeader\n"
"  Paramegers: (oaUInt4,oaBoolean)\n"
"    Calls: oaObserver_oaTechViaDefHeader(oaUInt4 priorityIn,oaBoolean enabledIn)\n"
"    Signature: oaObserver_oaTechViaDefHeader||simple-oaUInt4,simple-oaBoolean,\n"
"    Constructor oaObserver_oaTechViaDefHeader\n"
"  Paramegers: (oaObserver_oaTechViaDefHeader)\n"
"    Calls: (const oaObserver_oaTechViaDefHeader&)\n"
"    Signature: oaObserver_oaTechViaDefHeader||cref-oaObserver_oaTechViaDefHeader,\n"
;

// ------------------------------------------------------------------
PyTypeObject PyoaObserver_oaTechViaDefHeader_Type = {
    PyObject_HEAD_INIT(&PyType_Type)
    0,
    "oaObserver_oaTechViaDefHeader",
    sizeof(PyoaObserver_oaTechViaDefHeaderObject),
    0,
    (destructor)oaObserver_oaTechViaDefHeader_tp_dealloc,	/* tp_dealloc */
    0,	/* tp_print */
    0,					/* tp_getattr */
    0,					/* tp_setattr */
    (cmpfunc)oaObserver_oaTechViaDefHeader_tp_compare,	/* tp_compare */
    (reprfunc)oaObserver_oaTechViaDefHeader_tp_repr,	/* tp_repr */
    0,					/* tp_as_number */
    0,					/* tp_as_sequence */
    0,					/* tp_as_mapping */
    0,					/* tp_as_hash */
    0,					/* tp_as_call */
    0,					/* tp_str */
    0,					/* tp_getattro */
    0,					/* tp_setattro */
    0,					/* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE, /* tp_flags */
    oaObserver_oaTechViaDefHeader_doc,	/* tp_doc */
    0,					/* tp_traverse */
    0,					/* tp_clear */
    0,					/* tp_richcompre */
    0,					/* tp_weaklistoffset */
    0,					/* tp_iter */
    0,					/* tp_iternext */
    0,					/* tp_methods */
    0,					/* tp_members */
    0,					/* tp_getset */
    &PyoaStdObserver_oaTechViaDefHeader_oaTechViaDefHeaderModTypeEnum_Type,	/* tp_base */
    0,					/* tp_dict */
    0,					/* tp_descr_get */
    0,					/* tp_descr_set */
    0,					/* tp_dictoffset */
    0,					/* tp_init */
    PyType_GenericAlloc,	/* tp_alloc */
    oaObserver_oaTechViaDefHeader_new,	/* tp_new */
    _PyObject_Del,	/* tp_free */
};


// ------------------------------------------------------------------
//  Type Init:
// ------------------------------------------------------------------

int
PyoaObserver_oaTechViaDefHeader_TypeInit(PyObject* mod_dict)
{
    if (PyType_Ready(&PyoaObserver_oaTechViaDefHeader_Type)<0) {
      printf("** PyType_Ready failed for: oaObserver_oaTechViaDefHeader\n");
      return -1;
    }

    if (PyDict_SetItemString(mod_dict,"oaObserver_oaTechViaDefHeader",
           (PyObject*)(&PyoaObserver_oaTechViaDefHeader_Type))<0) {
       printf("** Failed to add type name to module dictionary for: oaObserver_oaTechViaDefHeader\n");
       return -1;
    }
    return 0;
}

