#*******************************************************************
#   Copyright 2002-2008  LSI Corporation
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#*******************************************************************
#
#--------------------------------------------------------------------
# Read XML files generated by Doxygen (v 1.2.15).
# Use these files to generate class and function descriptions for
# the Python/OpenAccess interface.
#--------------------------------------------------------------------
#

from xml.dom.ext.reader.Sax import FromXmlStream
from xml.dom.ext import PrettyPrint

import types
import string
import pprint
import re
import os
import sys

# ===================================================================
class cReadDoxygenXML:
  __doc__="cReadDoxygenXML - Read a docygen XML file."

  #-------------------------------------------------
  # Open a file 
  def __init__(self,file):
    self.mFile=file
    self.mClose=0
    if (type(file)==types.StringType):
      try:
        self.mFp=open(file,"r")
        self.mClose=1
      except:
        msg="Can't Open File: %s"%file
        print msg
        raise
    else:
      self.mFp=file

    self.mPatNl=re.compile("\s+",re.M)
    self.mPat=re.compile(" +",re.M)
    self.mPatBNl=re.compile(" *\n",re.M)
    self.mPatANl=re.compile("\n *",re.M)
    self.mPatMNl=re.compile("\n+",re.M)
    self.mPatFNl=re.compile("^[ \n]*",re.M)
    self.mPatLNl=re.compile("[ \n]*$",re.M)
    self.mMapTable=""
    for i in range(256):
      if (i<128):
        self.mMapTable+=chr(i)
      else:
        self.mMapTable+=' '

  #-------------------------------------------------
  # PackName - Remove extra spaced from a template name
  # They get packed here, so we don't have to pack them later.
  def PackName(self,tname):
    # add spaces around dilimiters
    if (string.find(tname,'<')<0): return tname
    if (string.find(tname,'>')<0): return tname
    tname=string.replace(tname,',',' ')
    tname=string.replace(tname,'<',' < ')
    tname=string.replace(tname,'>',' > ')
    # Split by spaces
    tokens=string.split(tname)
    start=tokens.index('<')
    end=tokens.index('>')
    clsname=tokens[start-1]+'<'
    first=1
    # Iterate on template args
    for i in range(start+1,end):
      if (first): first=0
      else: clsname+=','
      clsname+=tokens[i]
    clsname+='>'
    rest=tokens[0:start-1]
    rest.append(clsname)
    for item in tokens[end+1:]:rest.append(item)
    result=string.join(rest)
    return result

  #-------------------------------------------------
  # Find the first childnode with the given nodename
  def FindNodeName(self,obj,name):
    for node in obj.childNodes:
      if (node.nodeName==name):
        return node
    return None

  #-------------------------------------------------
  # Find all childnode with the given nodename
  def FindNodeNames(self,obj,name):
    result=[]
    for node in obj.childNodes:
      if (node.nodeName==name):
        result.append(node)
    return result

  #-------------------------------------------------
  # Get all the text
  def GetText(self,obj,depth=0):
    result=""
    for node in obj.childNodes:
      if (node.nodeType==node.TEXT_NODE):
        value=self.mPatNl.sub(" ",node.data)
        result+=' '+value
      elif (node.nodeName=="para"):
        value=self.GetText(node,depth+1)
        result+='\n'+value+'\n'
      elif (node.nodeName=="listitem"):
        value=self.GetText(node,depth+1)
        result+='\n'+value+'\n'
      elif (node.nodeName=="htmlonly"):
        pass
      else:
        value=self.GetText(node,depth+1)
        result+=' '+value
    if (depth==0):
      result=self.mPat.sub(" ",result)
      result=self.mPatBNl.sub("\n",result)
      result=self.mPatANl.sub("\n",result)
      result=self.mPatMNl.sub("\n",result)
      result=self.mPatFNl.sub("",result)
      result=self.mPatLNl.sub("",result)
      result=string.translate(result,self.mMapTable)
    return result

  #-------------------------------------------------
  # Find the first Text node child and return its value
  def GetNamedText(self,obj,name):
    node=self.FindNodeName(obj,name)
    if (node==None): return None
    return self.GetText(node)

  #-------------------------------------------------
  # Find the Doxygen description data
  def GetDescription(self,obj,dct=None):
    brdesc=self.FindNodeName(obj,'briefdescription')
    if (brdesc!=None):
      brdesc=self.GetText(brdesc)
    drdesc=self.FindNodeName(obj,'detaileddescription')
    if (drdesc!=None):
      drdesc=self.GetText(drdesc)
    if (type(dct)==types.DictType):
      dct['briefdescription']=brdesc
      dct['detaileddescription']=drdesc
    return [brdesc,drdesc]


  #-------------------------------------------------
  # Find child nodes that have a nodeName matching name
  #   Then based on the kind attribute call the dispatch
  #   function given in the dict parameter
  def ProcessNamedKinds(self,obj,name,dct):
    values=[]
    for node in obj.childNodes:
      if (node.nodeName!=name): continue
      if (not node.hasAttribute('kind')): continue
      kind=node.getAttribute('kind')
      if (dct.has_key(kind)):
        func,data=dct[kind]
        result=func(node,data)
    return values

  #-------------------------------------------------
  # Find child nodes with a nodeName matching name
  #   Then call the given function on these nodes
  def ProcessNamedNodes(self,obj,name,func,data):
    for node in obj.childNodes:
      if (node.nodeName!=name): continue
      func(node,data)

  #-------------------------------------------------
  # Find first child node with a nodeName matching name
  #   Then call the given function on these nodes
  def ProcessNamedNode(self,obj,name,func,data):
    for node in obj.childNodes:
      if (node.nodeName!=name): continue
      func(node,data)
      break

  #-------------------------------------------------
  #-------------------------------------------------
  # Fetch the parameter types for a function call
  def FunctionParams(self,obj,lst):
    value=self.GetNamedText(obj,'type')
    value=self.PackName(value)
    d={'category':'functionparam',
       'type':value,
       }
    value=self.GetNamedText(obj,'declname')
    if (value):
      d['declname']=value
    value=self.GetNamedText(obj,'defval')
    if (value):
      d['defval']=value
    lst.append(d)

  #-------------------------------------------------
  # Process the return type comment
  def FunctionReturn(self,obj,dct):
    name=self.GetText(obj)
    if (name!=None):
      dct['return']=name


  # for Doxegen 1.4
  if (0):
        #-------------------------------------------------
        # Process the ParamDocs
        def FunctionParamDocList(self,obj,dct):
          param_name=""
          param_desc=""
          for node in obj.childNodes:
            if (node.nodeName=='parameternamelist'):
              # this has a nested parametername, but should be ok
              param_name=self.GetText(node)
            if (node.nodeName=='parameterdescription'):
              param_desc=self.GetText(node)
              for param in dct['param']:
                if (param.has_key('declname') and param['declname']==param_name):
                  param['description']=param_desc

        #-------------------------------------------------
        # Process the ParamDocsItem
        def FunctionParamDocItem(self,obj,dct):
          self.ProcessNamedNodes(obj,'parameteritem',self.FunctionParamDocList,dct)

        #-------------------------------------------------
        # Process the ParamDocs
        def FunctionParamDoc(self,obj,dct):
          self.ProcessNamedNodes(obj,'parameterlist',self.FunctionParamDocItem,dct)



  #-------------------------------------------------
  # Process the ParamDocs
  def FunctionParamDocList(self,obj,dct):
    param_name=""
    param_desc=""
    for node in obj.childNodes:
      if (node.nodeName=='parametername'):
        param_name=self.GetText(node)
      if (node.nodeName=='parameterdescription'):
        param_desc=self.GetText(node)
        for param in dct['param']:
          if (param.has_key('declname') and param['declname']==param_name):
            param['description']=param_desc

  #-------------------------------------------------
  # Process the ParamDocs
  def FunctionParamDoc(self,obj,dct):
    self.ProcessNamedNodes(obj,'parameterlist',self.FunctionParamDocList,dct)

  #-------------------------------------------------
  # Process a function definition
  def ProcessFunction(self,obj,data):
    lst,protect=data
#        print "FUNCTION"
    name=self.GetNamedText(obj,'name')
    if (not name): return
    typ=self.GetNamedText(obj,'type')
    if (typ==None): return
    name=self.PackName(name)
    typ=self.PackName(typ)
#        if (not obj.hasAttribute("virt")): return
    virt=obj.getAttribute("virt")
    const=obj.getAttribute("const")
    params=[]
    fun={'category':'function',  # This is a function
         'name':name,        # Name of the function
         'type':typ,         # Return type of function
         'param':params,     # Parameter list
         'virt':virt,        # virtual setting
         'const':const,      # Const Settings
         'protect':protect,
         }
    self.ProcessNamedNodes(obj,'param',self.FunctionParams,params)
    self.GetDescription(obj,fun)
    node=self.FindNodeName(obj,"detaileddescription")
    if (node!=None):
      self.ProcessNamedKinds(node,'simplesect',{
        'return':[self.FunctionReturn,fun],
      })
      self.ProcessNamedNodes(node,'para',self.FunctionParamDoc,fun)

    self.ProcessNamedNode(obj,"templateparamlist",self.ProcessClassTemplate,fun)

    lst.append(fun)    # this allows function name overloading
#        print "Function:",fun

  #-------------------------------------------------
  #-------------------------------------------------
  # Fetch the enum values for an enum type
  def EnumValue(self,obj,lst):
    name=self.GetNamedText(obj,'name')
    d={'category':'enum_value',
       'name':name,
    }
    name=self.GetNamedText(obj,'initializer')
    if (name):
      d['initializer']=name
    lst.append(d)

  #-------------------------------------------------
  # Process an enum definition
  def ProcessEnum(self,obj,data):
    dct,protect=data
#        print "ENUM"
    name=self.GetNamedText(obj,'name')
    if (not name): return
    values=[]
    enum={'category':'enum',
          'name':name,
          'values':values,
          'prot':protect,
          }
    self.ProcessNamedNodes(obj,'enumvalue',self.EnumValue,values)
    self.GetDescription(obj,enum)
    dct[name]=enum
#        print "Enum:",enum

  #-------------------------------------------------
  #-------------------------------------------------
  # Process a variable definition
  def ProcessVar(self,obj,data):
    dct,protect=data
#        print "VAR"
    name=self.GetNamedText(obj,'name')
    if (not name): return
    typ=self.GetNamedText(obj,'type')
    if (not typ): return
    var={'category':'var',
         'name':name,
         'type':typ,
         'prot':protect,
         }
    self.GetDescription(obj,var)
    dct[name]=var
#        print "Var:",var

  #-------------------------------------------------
  #-------------------------------------------------
  # Process a typedef definition
  def ProcessTypedef(self,obj,data):
    dct,protect=data
#        print "TYPEDEF"
    name=self.GetNamedText(obj,'name')
    if (not name): return
    typ=self.GetNamedText(obj,'type')
    if (not typ): return
    typedef={'category':'typedef',
             'name':name,
             'type':typ,
             'prot':protect,
             }
    df=self.GetNamedText(obj,'definition')
    if (df): typedef['definition']=df
             
    self.GetDescription(obj,typedef)
    dct[name]=typedef
#        print "Typedef:",typedef

  #-------------------------------------------------
  #-------------------------------------------------
  # Fetch the parameter names for a define 
  def DefineParams(self,obj,lst):
    name=self.GetNamedText(obj,'defname')
    d={'category':'defineparam',
       'name':name,
       }
    lst.append(d)

  #-------------------------------------------------
  # Process a define definition
  def ProcessDefine(self,obj,data):
    dct,protect=data
#        print "DEFINE"
    name=self.GetNamedText(obj,'name')
    if (not name): return
    body=self.GetNamedText(obj,'initializer')
    if (not body): return
    params=[]
    define={'category':'define',
            'name':name,
            'body':body,
            'param':params,
            'prot':protect,
             }
    self.ProcessNamedNodes(obj,'param',self.DefineParams,params)
    self.GetDescription(obj,define)
    dct[name]=define
#        print "Define:",define

  #-------------------------------------------------
  #-------------------------------------------------
  def ProcessTypeSection(self,obj,lst):
    self.ProcessNamedKinds(obj,'memberdef',{
        'enum':[self.ProcessEnum,[lst[0]['enums'],lst[1]]],
        'typedef':[self.ProcessTypedef,[lst[0]['typedefs'],lst[1]]],
        'define':[self.ProcessDefine,[lst[0]['defines'],lst[1]]],
        'variable':[self.ProcessVar,[lst[0]['vars'],lst[1]]],
        })

  #-------------------------------------------------
  def ProcessFriendSection(self,obj,lst):
    self.ProcessNamedKinds(obj,'memberdef',{
        'friend':[self.ProcessFunction,lst],
        })

  #-------------------------------------------------
  def ProcessFunctionSection(self,obj,lst):
    self.ProcessNamedKinds(obj,'memberdef',{
        'function':[self.ProcessFunction,lst],
        })

  #-------------------------------------------------
  #-------------------------------------------------
  # Process a 'file' type xml file.
  # These contain: function, enums, defeins, typedef, and vars
  def ProcessFile(self,obj,lst):
#        print "PROCESSFILE"
    functions=[]
    result={'category':'file',
            'functions':functions,
            'enums':{},
            'defines':{},
            'typedefs':{},
            'vars':{},
            }
    name=self.GetNamedText(obj,'compoundname')
    if (not name): return None
    print "  Found File Data:",name
    self.ProcessNamedKinds(obj,'sectiondef',{
        'enum':[self.ProcessTypeSection,[result,'global']],
        'var':[self.ProcessTypeSection,[result,'global']],
        'define':[self.ProcessTypeSection,[result,'global']],
        'typedef':[self.ProcessTypeSection,[result,'global']],
        'func':[self.ProcessFunctionSection,[functions,'global']],
        })

    self.GetDescription(obj,result)
#        print "EndFile: ",result
    lst.append(result)

  #-------------------------------------------------
  # Process the template section of a class
  def ProcessClassTemplateParam(self,obj,dct):
    typ=self.GetNamedText(obj,'type')
    name=self.GetNamedText(obj,'name')
    if (not name): name=self.GetNamedText(obj,'declname')
    defval=self.GetNamedText(obj,'defval')
    if (typ and name):
      lst=dct.get('template',[])
      data={
        'type':typ,
        'name':name,
      }
      if (defval): data['defval']=defval
      lst.append(data)
      dct['template']=lst

  #-------------------------------------------------
  # Process the template section of a class
  def ProcessClassTemplate(self,obj,dct):
    self.ProcessNamedNodes(obj,"param",self.ProcessClassTemplateParam,dct)

  #-------------------------------------------------
  # Find the Doxygen description data
  def GetBaseClass(self,obj,result):
    result['bases']=[]
    classname=result['name']
    baseclassname=None
    # Check for basecompoundref as basename
    base=self.FindNodeName(obj,'basecompoundref')
    if (base):
      baseclassname=base.getAttribute('refid')
      if (baseclassname[0:5]=='class'): baseclassname=baseclassname[5:]
      baseclassname=string.replace(baseclassname,' ','')
    # Check the inheritance graph
    inodes=[]
    inheritance=self.FindNodeName(obj,'inheritancegraph')
    if (inheritance!=None):
      inodes=self.FindNodeNames(inheritance,'node')
    id=None
    for node in inodes:
      name=self.GetNamedText(node,'label')
      name=name.replace(' ','')
      if (name!=classname):
        link=self.FindNodeName(node,'link')
        if (not link): continue
        name=link.getAttribute('refid')
        if (name[0:5]=='class'): name=name[5:]
      # Find ourself in the graph, and get child
      if (name==classname):
        child=self.FindNodeName(node,'childnode')
        if (child!=None):
          id=child.getAttribute('refid')
    # Now find the child id
    if (id!=None):
      for node in inodes:
        if (node.getAttribute('id')==id):
          baseclassname=self.GetNamedText(node,'label')
          baseclassname=string.replace(baseclassname,' ','')
          break
    # Record the baseclassname if any
    if (baseclassname):
      result['bases'].append(baseclassname)

  #-------------------------------------------------
  # Process a 'class' type xml file.
  # These contain a class definition
  def ProcessClass(self,obj,lst):
#        print "PROCESSCLASS"
    functions=[]
    sfunctions=[]
    friends=[]
    name=self.GetNamedText(obj,'compoundname')
    name=self.PackName(name)
    if (not name): return None
    print "  Found Class Data:",name
    result={'category':'class',
            'name':name,
            'functions':functions,
            'sfunctions':sfunctions,
            'typedefs':{},
            'enums':{},
            'vars':{},
            'defines':{},
            'friends':friends,
            }
    self.ProcessNamedNode(obj,"templateparamlist",self.ProcessClassTemplate,result)
    self.ProcessNamedKinds(obj,'sectiondef',{
        'public-func':[self.ProcessFunctionSection,[functions,'public']],
        'private-func':[self.ProcessFunctionSection,[functions,'private']],
        'protected-func':[self.ProcessFunctionSection,[functions,'protected']],
        'public-static-func':[self.ProcessFunctionSection,[sfunctions,'public']],
        'public-type':[self.ProcessTypeSection,[result,'public']],
        'protected-type':[self.ProcessTypeSection,[result,'protected']],
        'private-type':[self.ProcessTypeSection,[result,'private']],
        'public-attrib':[self.ProcessTypeSection,[result,'public']],
        'protected-attrib':[self.ProcessTypeSection,[result,'protected']],
        'private-attrib':[self.ProcessTypeSection,[result,'private']],
        'friend':[self.ProcessFriendSection,[friends,'global']],
        })

    self.GetDescription(obj,result)
    self.GetBaseClass(obj,result)

#        print "EndClass: ",result
    lst.append(result)

  #-------------------------------------------------
  # Process an XML file.
  # Decide if its a class for file type of file.
  def Process(self,result=None):
    self.mDoc=FromXmlStream(self.mFp)
    if (self.mClose):
        self.mFp.close()
    print "  Processing"
    self.mElement=self.mDoc.documentElement
    if (result==None):
        result=[]
    self.ProcessNamedKinds(self.mElement,'compounddef',{
        'file':[self.ProcessFile,result],
        'class':[self.ProcessClass,result],
        })
    return result

  #-------------------------------------------------
  #-------------------------------------------------
  # Write the data to a .py file
  def WriteData(self,data,file):
    print "  Writting Data:",file
    sys.stdout.flush()
    fp=open(file,"w")
    fp.write("""\
#*******************************************************************
#   Copyright 2002-2008  LSI Corporation
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#*******************************************************************
#
#--------------------------------------------------------------------
# The following code description was extracted from XML files.
#  The XML files where generated with Doxygen.
#  The XML files where processed by pyXml2DoxData.py
#--------------------------------------------------------------------

data=\\
""")
    pprint.pprint(data,fp)
    fp.write("\n")
    fp.close()
    
# ===================================================================
def FileTime(file):
  try:
    st=os.stat(file)
    return [st.st_mtime,st.st_atime,st.st_size,st.st_mode]
  except:
    return None

# ===================================================================
# Process a list of files and process each file
#   files - a list of file names
#   indir - the input directory for files
#   outdir - the output directory for files
def ProcessFiles(files,indir,outdir):
  try:
    os.mkdir(outdir)
  except:
    pass

  name=outdir+"/__init__.py"
  print "  Writting Data:",name
  sys.stdout.flush()
  fp=open(name,"w")
  fp.write("#\ndata=[]\n")
  fp.close()

  for fp in files:
    result=[]
    infile=indir+"/"+fp+'.xml'
    print "Reading File:",infile
    outfile=outdir+'/'+fp+'.py'
    itime=FileTime(infile)
    otime=FileTime(outfile)
    if (otime>itime):
      print "  Output Current, Skipping"
      continue
    
    sys.stdout.flush()
    obj=cReadDoxygenXML(infile)
    obj.Process(result)
    obj.WriteData(result,outfile)

     
