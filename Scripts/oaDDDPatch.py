#*******************************************************************
#   Copyright 2002-2008  LSI Corporation
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#*******************************************************************
#
#  OA Patch routine for class data
#

import string
import os
import os.path
import re

# ===================================================================
def lPatchObserverName(name):
  name=re.sub("oaVersionedObserver","oaObserver",name)
  return name

# ===================================================================
# This route patch for the specilaized template base classes in .xml
# These are not generated by doxygen
#
def PatchClasses(data):
  # ==========================================
  # Patch the return type on oaCollection for 
  #   function:  operator oaIterState
  #   should be: operator oaIterState<obj>*
  for item in data.mData:
    if (item['category']!='class'): continue
    if (item.has_key('template')): continue # skip general templates
    for cat in ['functions','sfunctions']:
      for fun in item[cat]:
          rettype=fun['type']
          if (string.find(rettype,'<')>=0):
            fun['type']=string.replace(rettype,',*','*')
          for param in fun['param']:
            paramtype=param['type']
            if (string.find(paramtype,'<')>=0):
              param['type']=string.replace(paramtype,',*','*')
  
  # ==========================================
  # Patch the oaArray(const T array[], oaUInt4 numElementsIn)
  #  from: (const T arrray, 
  #  to:   (const T* array,
  for item in data.mData:
    if (item['category']!='class'): continue
    if (item['name']=='oaArray'):
      for fun in item['functions']:
        if (fun['name']!='oaArray'): continue
        for param in fun['param']:
          if (param['type']!='const T'): continue
          param['type']='const T *'
    if (item['name']=='oaArrayBase'):
      for fun in item['functions']:
        if (fun['name']!='oaArrayBase'): continue
        for param in fun['param']:
          if (param['type']!='const T'): continue
          param['type']='const T *'
  
  # ==========================================
  # Patch the oaPointArray(const oaPoint pointsIn[], oaUInt4 numElementsIn)
  #  from: (const oaPoint pointsIn, 
  #  to:   (const oaPoint* pointsIn,
  for item in data.mData:
    if (item['category']!='class'): continue
    if (item['name']!='oaPointArray'): continue
    for fun in item['functions']:
      if (fun['name']!='oaPointArray'): continue
      for param in fun['param']:
        if (param['type']!='const oaPoint'): continue
        param['type']='const oaPoint *'
  
  # ==========================================
  # Patch the oaVersionedObserver<oaWafer>
  #  to:   oaVersionedObserver<oaWafer,oacObserverRevision>
  # Default template expansion does work correctly for this
  for item in data.mData:
    if (item['category']!='class'): continue
    if (item['name']!='oaVersionedObserver<oaWafer>'): continue
    item['name']=u'oaVersionedObserver<oaWafer,oacObserverRevision>'
  
  for item in data.mData:
    if (item['category']!='class'): continue
    item['name']=lPatchObserverName(item['name'])
    for cat in ['functions','sfunctions']:
      for fun in item[cat]:
        fun['name']=lPatchObserverName(fun['name'])
        fun['type']=lPatchObserverName(fun['type'])
        for param in fun['param']:
          param['type']=lPatchObserverName(param['type'])

  # ==========================================
  # Define some manual types and arrays
  classdata={
    u'char':{'array':'manual','builtin':'1'},
    u'int':{'array':'manual','builtin':'1'},
    u'oaByte':{'array':'manual',},
    u'oaChar':{'array':'manual','size':'0'},
    u'oaString':{},
    u'oaFloat':{},
    u'oaDouble':{},
    u'oaCoord':{},
    u'oaDist':{},
    u'oaOffset':{},
    u'oaInt8':{},
    u'oaInt4':{},
    u'oaInt2':{},
    u'oaInt1':{},
    u'oaUInt8':{},
    u'oaUInt4':{},
    u'oaUInt2':{},
    u'oaBoolean':{},
    u'oaLayerNum':{},
    u'oaPurposeNum':{},
    u'oaTime':{},
    u'oaComplex_oaFloat':{},
    u'oaComplex_oaDouble':{},
  }
  classnames=classdata.keys()
  for name in classnames:
    dct={'name':name,
         'category':'manual',
         'bases':[],
         'choice':'%s\n%s'%(name,name),
         'detaileddescription':'',
         'briefdescription':'',
         'array':classdata[name].get('array','auto')
         }
    for key in ['size','builtin']:
      if (classdata[name].has_key(key)):
        dct[key]=classdata[name][key]
    data.mClasses[name]=dct

  # ==========================================
  # Apply Patches: See Issues.txt file
  for item in data.mData:
    if (item['category']!='class'): continue
    if (item['name']=='oaDefNS'): 
      dct={
       'briefdescription': '',
       'category': 'function',
       'const': u'no',
       'detaileddescription': '',
       'name': u'oaDefNS',
       'param':[],
       'protect': 'public',
       'type': u'',
       'virt': u'non-virtual'}
      item['functions'].append(dct)

    #if (item['name']=='oaMfgLayerArray'): 
    #  for fun in item['functions']:
    #    if (fun['name']=='operator[]' and fun['const']=='yes'):
    #      fun['type']=u'const oaUInt4 &'

    #if (item['name'] in ['oaBundleName', 'oaName', 'oaNameBase', 'oaSimpleName']):
    #  for fun in item['functions']:
    #    if (fun['name']=='addHierMem'):
    #      for param in fun['param']:
    #        if (param['type']=='const char *'):
    #          param['type']=u'const oaChar *'

    # This patch is not an API Issue.
    # It just allows void* to be used as oaByte*
    if (item['name']=='oaFile'): 
      for fun in item['functions']:
        if (fun['name'] in ['read', 'write']):
          for param in fun['param']:
            if (param['type']=='void *'):
              param['type']=u'oaByte *'

  # ==========================================
  # Add getNext for specialized iterators
  for item in data.mData:
    if (item['category']!='class'): continue
    # Check and add getNext function if needed
    if (item['name'][0:6]=='oaIter'):
      hasNext=0
      for fun in item['functions']:
        if (fun['name']=='getNext'): hasNext=1
      if (not hasNext):
        print "ADDing getNext: %s"%(item['name'])
        typ=item['name'][7:-1]
        item['functions'].append(
          {'briefdescription': '',
           'category': 'function',
           'const': u'no',
           'detaileddescription': '',
           'name': u'getNext',
           'param': [],
           'protect': 'public',
           'type': '%s *'%typ,
           'virt': u'non-virtual'},
        )

  # ==========================================
  # Apply Patches: added in 2.2.5. These don't get the correct return template types
  for item in data.mData:
    if (item['category']!='class'): continue
    if (item['name']!='oaNetTermArrayBase'): continue
    for fun in item['functions']:
      if (fun['name']=='get' or fun['name']=='operator[]'):
        if (fun['type'][0:5]=='const'):
          fun['type']= u'const oaNetTermPair<NetType,TermType> &'
        else:
          fun['type']= u'oaNetTermPair<NetType,TermType> &'
    
  # ==========================================
  # 2.2.6: Treat oaBuildInfo as a managed DB type, so remove the constructor
  for item in data.mData:
    if (item['category']!='class'): continue
    if (item['name']!='oaBuildInfo'): continue
    newlst = []
    for fun in item['functions']:
      if (fun['name'] == 'oaBuildInfo'): continue
      newlst.append(fun)
    item['functions']=newlst

  # ==========================================
  # 2.2.6: Since we aren't extracting or compiling with: OA_DEPRECATED
  # We need to remove the following duplicates
  for item in data.mData:
    if (item['category']!='class'): continue
    if (item['name']=='oaLayerArrayValue'): 
      newlst = []
      for fun in item['functions']:
        if (fun['name'] == 'create'): 
          if (fun['param'][1]['type']=='oaLayerArray &'): continue
        newlst.append(fun)
      item['functions']=newlst
    if (item['name']=='oaOccArc'): 
      newlst = []
      for fun in item['functions']:
        if (fun['name'] == 'getEllipseBBox'): 
          if (fun['const']=='no'): continue
        if (fun['name'] == 'getStartAngle'): 
          if (fun['const']=='no'): continue
        if (fun['name'] == 'getStopAngle'): 
          if (fun['const']=='no'): continue
        newlst.append(fun)
      item['functions']=newlst
    if (item['name']=='oaViaDefArrayValue'): 
      newlst = []
      for fun in item['functions']:
        if (fun['name'] == 'create'): 
          if (fun['param'][1]['type']=='oaViaDefArray &'): continue
        newlst.append(fun)
      item['functions']=newlst
    
  
